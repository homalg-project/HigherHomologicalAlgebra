<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (StableCategories) - Chapter 1: Exact and Frobenius Categories</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1.html">[MathJax off]</a></p>
<p><a id="X806FCA1E826CB3DC" name="X806FCA1E826CB3DC"></a></p>
<div class="ChapSects"><a href="chap1_mj.html#X806FCA1E826CB3DC">1 <span class="Heading">Exact and Frobenius Categories</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7D03633A7D98026B">1.1 <span class="Heading">GAP categories</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8218A4C07B347D6D">1.1-1 IsCapCategoryShortSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7C7383557981C69C">1.1-2 IsCapCategoryMorphismOfShortSequences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CA59D1E7DADD783">1.1-3 IsCapCategoryShortExactSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X788847887B6F8217">1.1-4 IsCapCategoryConflation</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7C68BE597DB754B6">1.2 <span class="Heading">Exact categories operations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7B52F7A5834F4772">1.2-1 IsExactCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7811C3CE8142333A">1.2-2 IsInflation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X79EB8A527CBFA27F">1.2-3 IsDeflation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7E737AA87E04F8EA">1.2-4 IsConflationPair</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7BE431ED81B81D8D">1.2-5 ExactCokernelObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7EDF6125848C51F5">1.2-6 ExactCokernelProjection</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8447687F839F3231">1.2-7 ExactCokernelProjectionWithGivenExactCokernelObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CC1AA4D7D5A4564">1.2-8 ExactCokernelColift</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X80FF949B7A5C44C8">1.2-9 ExactCokernelObjectFunctorial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7B2916E88553E9FC">1.2-10 ExactCokernelObjectFunctorialWithGivenExactCokernelObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X83755C2686E92DB4">1.2-11 ColiftAlongDeflation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X82A7834B7BB4C336">1.2-12 ExactKernelObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X857917A17F7D5DE4">1.2-13 ExactKernelEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8713CEEE7E0E31E1">1.2-14 ExactKernelEmbeddingWithGivenExactKernelObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8763D19680624B26">1.2-15 ExactKernelLift</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X82EA37EE83B85158">1.2-16 ExactKernelObjectFunctorial</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X83267CB385B683AF">1.2-17 ExactKernelObjectFunctorialWithGivenExactKernelObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8116CB597B2A3970">1.2-18 LiftAlongInflation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7A36F1517EB22248">1.2-19 <span class="Heading">Exact Fiber Product</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CDE63067EE0779D">1.2-20 ExactFiberProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X851EAD8D7C9F259E">1.2-21 ProjectionInFirstFactorOfExactFiberProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X802EAF8C784080A2">1.2-22 ProjectionInSecondFactorOfExactFiberProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7DB5A88F875A92BC">1.2-23 UniversalMorphismIntoExactFiberProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7F7BC1C283F5193E">1.2-24 <span class="Heading">Exact Pushout</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7F4025407EBEFCAF">1.2-25 ExactPushout</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7DF4981F7DD6E37B">1.2-26 InjectionOfFirstCofactorOfExactPushout</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7C25B50381FE72D0">1.2-27 InjectionOfSecondCofactorOfExactPushout</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X854FA6D97D7228C3">1.2-28 UniversalMorphismFromExactPushout</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8365AF0D7CCCF816">1.2-29 UniversalMorphismFromExactPushoutWithGivenExactPushout</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X851987617A678E7F">1.2-30 <span class="Heading">Exact Categories With Enough E-projectives</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7864B1007C32441A">1.2-31 IsExactCategoryWithEnoughExactProjectives</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7F004F3882294703">1.2-32 IsExactProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X799EE9F880C76F05">1.2-33 ExactProjectiveLift</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7AB797AA7E467F0A">1.2-34 SomeExactProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X86313D6E7FB889EC">1.2-35 DeflationFromSomeExactProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X87739A8B7FE89898">1.2-36 <span class="Heading">Exact Categories With Enough E-injecitves</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X84A9AF9484068AC1">1.2-37 IsExactCategoryWithEnoughExactInjectives</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CAFD3007E885932">1.2-38 IsExactInjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7F8F3C02820441DC">1.2-39 ExactInjectiveColift</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X869DA05B85F7F112">1.2-40 SomeExactInjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7AD566E9805DA937">1.2-41 InflationIntoSomeExactInjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X85E3864B79AE0B00">1.2-42 IsLiftableAlongDeflationFromSomeExactProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X78BDE2BA7950284D">1.2-43 LiftAlongDeflationFromSomeExactProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X87D53EAB8275CCD8">1.2-44 IsColiftableAlongInflationIntoSomeExactInjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7E1207BA7C66FAFE">1.2-45 ColiftAlongInflationIntoSomeExactInjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7E777F887E00910C">1.2-46 IsFrobeniusCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X806A08297D4DE852">1.2-47 SchanuelsIsomorphismByInflationsIntoSomeExactInjectiveObjects</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X870156627E385E31">1.2-48 SchanuelsIsomorphismByDeflationsFromSomeExactProjectiveObjects</a></span>
</div></div>
</div>

<h3>1 <span class="Heading">Exact and Frobenius Categories</span></h3>

<p><a id="X7D03633A7D98026B" name="X7D03633A7D98026B"></a></p>

<h4>1.1 <span class="Heading">GAP categories</span></h4>

<p><a id="X8218A4C07B347D6D" name="X8218A4C07B347D6D"></a></p>

<h5>1.1-1 IsCapCategoryShortSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCapCategoryShortSequence</code>( <var class="Arg">seq_obj</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of short sequences.</p>

<p><a id="X7C7383557981C69C" name="X7C7383557981C69C"></a></p>

<h5>1.1-2 IsCapCategoryMorphismOfShortSequences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCapCategoryMorphismOfShortSequences</code>( <var class="Arg">seq_mor</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of morphisms of short sequences.</p>

<p><a id="X7CA59D1E7DADD783" name="X7CA59D1E7DADD783"></a></p>

<h5>1.1-3 IsCapCategoryShortExactSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCapCategoryShortExactSequence</code>( <var class="Arg">seq_obj</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of short exact sequences.</p>

<p><a id="X788847887B6F8217" name="X788847887B6F8217"></a></p>

<h5>1.1-4 IsCapCategoryConflation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCapCategoryConflation</code>( <var class="Arg">seq_obj</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of conflations. If a short sequence is a conflation, then it is a short exact sequence.</p>

<p><a id="X7C68BE597DB754B6" name="X7C68BE597DB754B6"></a></p>

<h4>1.2 <span class="Heading">Exact categories operations</span></h4>

<p><a id="X7B52F7A5834F4772" name="X7B52F7A5834F4772"></a></p>

<h5>1.2-1 IsExactCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsExactCategory</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The input is a <strong class="pkg">CAP</strong> category. The output is <code class="code">true</code> if <span class="SimpleMath">\(\CC\)</span> is an exact category with respect to some class <span class="SimpleMath">\(\EE\)</span> of short exact sequences.</p>

<p><a id="X7811C3CE8142333A" name="X7811C3CE8142333A"></a></p>

<h5>1.2-2 IsInflation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsInflation</code>( <var class="Arg">iota</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a boolian</p>

<p>The argument is a morphism <span class="SimpleMath">\(\iota:A\to B\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is whether or not <span class="SimpleMath">\(\iota\)</span> is an inflation.</p>

<p><a id="X79EB8A527CBFA27F" name="X79EB8A527CBFA27F"></a></p>

<h5>1.2-3 IsDeflation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDeflation</code>( <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a boolian</p>

<p>The argument is a morphism <span class="SimpleMath">\(\pi:B\to C\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is whether or not <span class="SimpleMath">\(\pi\)</span> is a deflation.</p>

<p><a id="X7E737AA87E04F8EA" name="X7E737AA87E04F8EA"></a></p>

<h5>1.2-4 IsConflationPair</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsConflationPair</code>( <var class="Arg">iota</var>, <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a boolian</p>

<p>The argument is a pair of morphisms <span class="SimpleMath">\(\iota:A\to B\)</span> and <span class="SimpleMath">\(\pi:B\to C\)</span>. The output is whether or not the pair <span class="SimpleMath">\((\iota,\pi)\)</span> defines a conflation.</p>

<p><a id="X7BE431ED81B81D8D" name="X7BE431ED81B81D8D"></a></p>

<h5>1.2-5 ExactCokernelObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactCokernelObject</code>( <var class="Arg">iota</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an object <span class="SimpleMath">\(C\)</span></p>

<p>The argument is an inflation <span class="SimpleMath">\(\iota:A\to B\)</span>. The output is the cokernel object <span class="SimpleMath">\(C\)</span> of <span class="SimpleMath">\(\iota\)</span>.</p>

<p><a id="X7EDF6125848C51F5" name="X7EDF6125848C51F5"></a></p>

<h5>1.2-6 ExactCokernelProjection</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactCokernelProjection</code>( <var class="Arg">iota</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a deflation <span class="SimpleMath">\(B\to C\)</span></p>

<p>The argument is an inflation <span class="SimpleMath">\(\iota:A\to B\)</span>. The output is a deflation <span class="SimpleMath">\(\pi(\iota):B\to C\)</span> with <span class="SimpleMath">\(C=\mathrm{ExactCokernelObject}(\iota)\)</span> such that the pair <span class="SimpleMath">\((\iota,\pi(\iota))\)</span> defines a conflation.</p>

<p><a id="X8447687F839F3231" name="X8447687F839F3231"></a></p>

<h5>1.2-7 ExactCokernelProjectionWithGivenExactCokernelObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactCokernelProjectionWithGivenExactCokernelObject</code>( <var class="Arg">iota</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a deflation <span class="SimpleMath">\(B\to C\)</span></p>

<p>The argument is an inflation <span class="SimpleMath">\(\iota:A\to B\)</span> and an object <span class="SimpleMath">\(C=\mathrm{ExactCokernelObject}(\iota)\)</span>. The output is a deflation <span class="SimpleMath">\(\pi(\iota):B\to C\)</span> such that <span class="SimpleMath">\((\iota,\pi(\iota))\)</span> defines a conflation.</p>

<p><a id="X7CC1AA4D7D5A4564" name="X7CC1AA4D7D5A4564"></a></p>

<h5>1.2-8 ExactCokernelColift</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactCokernelColift</code>( <var class="Arg">iota</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(C \to T\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota: A \rightarrow B\)</span> and a test morphism <span class="SimpleMath">\(\tau: B \rightarrow T\)</span> satisfying <span class="SimpleMath">\(\comp{\iota}{\tau} \sim 0\)</span>. The output is the morphism <span class="SimpleMath">\(\lambda: C \rightarrow T\)</span> with <span class="SimpleMath">\(C=\mathrm{ExactCokernelObject}(\iota)\)</span> and <span class="SimpleMath">\(\lambda\)</span> is given by the universal property of the cokernel object, i.e., <span class="SimpleMath">\(\comp{\pi(\iota)}{\lambda} \sim \tau\)</span> where <span class="SimpleMath">\(\pi(\iota) = \mathrm{ExactCokernelProjection}(\iota)\)</span>.</p>

<p><a id="X80FF949B7A5C44C8" name="X80FF949B7A5C44C8"></a></p>

<h5>1.2-9 ExactCokernelObjectFunctorial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactCokernelObjectFunctorial</code>( <var class="Arg">iota_1</var>, <var class="Arg">nu</var>, <var class="Arg">iota_2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(C_1 \to C_2\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota_1:A_1 \to B_1\)</span>, a morphism <span class="SimpleMath">\(\nu: B_1 \to B_2\)</span> and an inflation <span class="SimpleMath">\(\iota_2:A_2 \to B_2\)</span> such that there <span class="SimpleMath">\(\mu: A_1 \to A_2\)</span> with <span class="SimpleMath">\(\comp{\iota_1}{\nu} \sim \comp{\mu}{\iota_2}\)</span>. The operation delegates to the operation <span class="SimpleMath">\(\mathrm{ExactCokernelObjectFunctorialWithGivenExactCokernelObjects}(C_1,\iota_1,\nu,\iota_2,C_2)\)</span> such that <span class="SimpleMath">\(C_1=\mathrm{ExactCokernelObject}(\iota_1)\)</span>, <span class="SimpleMath">\(C_2=\mathrm{ExactCokernelObject}(\iota_2)\)</span>.</p>

<p><a id="X7B2916E88553E9FC" name="X7B2916E88553E9FC"></a></p>

<h5>1.2-10 ExactCokernelObjectFunctorialWithGivenExactCokernelObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactCokernelObjectFunctorialWithGivenExactCokernelObjects</code>( <var class="Arg">C_1</var>, <var class="Arg">iota_1</var>, <var class="Arg">nu</var>, <var class="Arg">iota_2</var>, <var class="Arg">C_2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(C_1 \to C_2\)</span></p>

<p>The arguments are an object <span class="SimpleMath">\(C_1\)</span>, an inflation <span class="SimpleMath">\(\iota_1:A_1 \to B_1\)</span>, a morphism <span class="SimpleMath">\(\nu: B_1 \to B_2\)</span>, an inflation <span class="SimpleMath">\(\iota_2:A_2 \to B_2\)</span> and an object <span class="SimpleMath">\(C_2\)</span> such that <span class="SimpleMath">\(C_1=\mathrm{ExactCokernelObject}(\iota_1)\)</span>, <span class="SimpleMath">\(C_2=\mathrm{ExactCokernelObject}(\iota_2)\)</span> and there exists a morphism <span class="SimpleMath">\(\mu: A_1 \to A_2\)</span> with <span class="SimpleMath">\(\comp{\iota_1}{\nu} \sim \comp{\mu}{\iota_2}\)</span>. The output is the universal morphism <span class="SimpleMath">\(\lambda: C_1 \rightarrow C_2\)</span> given by the universal property of the cokernel object, i.e., <span class="SimpleMath">\(\comp{\pi(\iota_1)}{\lambda} \sim \comp{\nu}{\pi(\iota_2)}\)</span> where <span class="SimpleMath">\(\pi(\iota_1) = \mathrm{ExactCokernelProjection}(\iota_1)\)</span> and <span class="SimpleMath">\(\pi(\iota_2) = \mathrm{ExactCokernelProjection}(\iota_2)\)</span>.</p>

<p><a id="X83755C2686E92DB4" name="X83755C2686E92DB4"></a></p>

<h5>1.2-11 ColiftAlongDeflation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ColiftAlongDeflation</code>( <var class="Arg">pi</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(C \to T\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi: B \rightarrow C\)</span> and a morphism <span class="SimpleMath">\(\tau: B \to T\)</span> such that <span class="SimpleMath">\(\tau\)</span> is coliftable along <span class="SimpleMath">\(\pi\)</span>. That is, <span class="SimpleMath">\(\comp{\iota(\pi)}{\tau} \sim 0\)</span>. The output is the unique colift morphism <span class="SimpleMath">\(\lambda:C\to T\)</span> of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\pi\)</span>.</p>

<p><a id="X82A7834B7BB4C336" name="X82A7834B7BB4C336"></a></p>

<h5>1.2-12 ExactKernelObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactKernelObject</code>( <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an object <span class="SimpleMath">\(K\)</span></p>

<p>The argument is a deflation <span class="SimpleMath">\(\pi:B\to C\)</span>. The output is the kernel object <span class="SimpleMath">\(K\)</span> of <span class="SimpleMath">\(\pi\)</span>.</p>

<p><a id="X857917A17F7D5DE4" name="X857917A17F7D5DE4"></a></p>

<h5>1.2-13 ExactKernelEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactKernelEmbedding</code>( <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an inflation <span class="SimpleMath">\(K\to B\)</span></p>

<p>The argument is a deflation <span class="SimpleMath">\(\pi:B\to C\)</span>. The output is an inflation <span class="SimpleMath">\(\iota(\pi):K\to B\)</span> with <span class="SimpleMath">\(K=\mathrm{ExactKernelObject}(\pi)\)</span> such that the pair <span class="SimpleMath">\((\iota(\pi),\pi)\)</span> defines a conflation.</p>

<p><a id="X8713CEEE7E0E31E1" name="X8713CEEE7E0E31E1"></a></p>

<h5>1.2-14 ExactKernelEmbeddingWithGivenExactKernelObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactKernelEmbeddingWithGivenExactKernelObject</code>( <var class="Arg">pi</var>, <var class="Arg">K</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an inflation <span class="SimpleMath">\(K\to B\)</span></p>

<p>The argument is a deflation <span class="SimpleMath">\(\pi:B\to C\)</span> and an object <span class="SimpleMath">\(K=\mathrm{ExactKernelObject}(\pi)\)</span>. The output is an inflation <span class="SimpleMath">\(\iota(\pi):K\to B\)</span> such that the pair <span class="SimpleMath">\((\iota(\pi),\pi)\)</span> defines a conflation.</p>

<p><a id="X8763D19680624B26" name="X8763D19680624B26"></a></p>

<h5>1.2-15 ExactKernelLift</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactKernelLift</code>( <var class="Arg">pi</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(T \to K\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi: B \rightarrow C\)</span> and a test morphism <span class="SimpleMath">\(\tau: T \rightarrow B\)</span> satisfying <span class="SimpleMath">\(\comp{\tau}{\pi} \sim 0\)</span>. The output is the morphism <span class="SimpleMath">\(\lambda: T \rightarrow K\)</span> with <span class="SimpleMath">\(K=\mathrm{ExactKernelObject}(\pi)\)</span> and <span class="SimpleMath">\(\lambda\)</span> is given by the universal property of the kernel object, i.e., <span class="SimpleMath">\(\comp{\lambda}{\iota(\pi)} \sim \tau\)</span> where <span class="SimpleMath">\(\iota(\pi) = \mathrm{ExactKernelEmbedding}(\pi)\)</span>.</p>

<p><a id="X82EA37EE83B85158" name="X82EA37EE83B85158"></a></p>

<h5>1.2-16 ExactKernelObjectFunctorial</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactKernelObjectFunctorial</code>( <var class="Arg">pi_1</var>, <var class="Arg">mu</var>, <var class="Arg">pi_2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(K_1 \to K_2\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi_1:B_1 \to C_1\)</span>, a morphism <span class="SimpleMath">\(\mu: B_1 \to B_2\)</span> and a deflation <span class="SimpleMath">\(\pi_2: B_2 \to C_2\)</span> such that there exists a morphism <span class="SimpleMath">\(\nu: C_1 \to C_2\)</span> with <span class="SimpleMath">\(\comp{\pi_1}{\nu} \sim \comp{\mu}{\pi_2}\)</span>. The operation delegates to the operation <span class="SimpleMath">\(\mathrm{ExactKernelObjectFunctorialWithGivenExactKernelObjects}(K_1,\pi_1,\mu,\pi_2,K_2)\)</span> where <span class="SimpleMath">\(K_1=\mathrm{ExactKernelObject}(\pi_1)\)</span> and <span class="SimpleMath">\(K_2=\mathrm{ExactKernelObject}(\pi_2)\)</span>.</p>

<p><a id="X83267CB385B683AF" name="X83267CB385B683AF"></a></p>

<h5>1.2-17 ExactKernelObjectFunctorialWithGivenExactKernelObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactKernelObjectFunctorialWithGivenExactKernelObjects</code>( <var class="Arg">K_1</var>, <var class="Arg">pi_1</var>, <var class="Arg">mu</var>, <var class="Arg">pi_2</var>, <var class="Arg">K_2</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(K_1 \to K_2\)</span></p>

<p>The arguments are an object <span class="SimpleMath">\(K_1\)</span>, a deflation <span class="SimpleMath">\(\pi_1:B_1 \to C_1\)</span>, a morphism <span class="SimpleMath">\(\mu: B_1 \to B_2\)</span>, a deflation <span class="SimpleMath">\(\pi_2: B_2 \to C_2\)</span> and an object <span class="SimpleMath">\(K_2\)</span> such that <span class="SimpleMath">\(K_1 = \mathrm{ExactKernelObject}(\pi_1)\)</span>, <span class="SimpleMath">\(K_2 = \mathrm{ExactKernelObject}(\pi_2)\)</span> and there exists a morphism <span class="SimpleMath">\(\nu: C_1 \to C_2\)</span> with <span class="SimpleMath">\(\comp{\pi_1}{\nu} \sim \comp{\mu}{\pi_2}\)</span>. The output is the universal morphism <span class="SimpleMath">\(\lambda: K_1 \rightarrow K_2\)</span> given by the universal property of the kernel object, i.e., <span class="SimpleMath">\(\comp{\lambda}{\iota(\pi_2)} \sim \comp{\iota(\pi_1)}{\mu}\)</span> where <span class="SimpleMath">\(\iota(\pi_1) = \mathrm{ExactKernelEmbedding}(\pi_1)\)</span> and <span class="SimpleMath">\(\iota(\pi_2) = \mathrm{ExactKernelEmbedding}(\pi_2)\)</span>.</p>

<p><a id="X8116CB597B2A3970" name="X8116CB597B2A3970"></a></p>

<h5>1.2-18 LiftAlongInflation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftAlongInflation</code>( <var class="Arg">iota</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(C \to T\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota: A \rightarrow B\)</span> and a morphism <span class="SimpleMath">\(\tau: T \to B\)</span> such that <span class="SimpleMath">\(\tau\)</span> is liftable along <span class="SimpleMath">\(\iota\)</span>. That is, <span class="SimpleMath">\(\comp{\tau}{\pi(\iota)} \sim 0\)</span>. The output is the unique lift morphism <span class="SimpleMath">\(\lambda:T\to A\)</span> of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\iota\)</span>.</p>

<p><a id="X7A36F1517EB22248" name="X7A36F1517EB22248"></a></p>

<h5>1.2-19 <span class="Heading">Exact Fiber Product</span></h5>

<p>Given a deflation <span class="SimpleMath">\(\pi:A\to C\)</span> and a morphism <span class="SimpleMath">\(\alpha:B\to C\)</span>, an exact fiber product diagram of <span class="SimpleMath">\((\pi,\alpha)\)</span> is defined by an object <span class="SimpleMath">\(A\times_C B\)</span>, a morphism <span class="SimpleMath">\(p_A:A\times_C B\to A\)</span> and a deflation <span class="SimpleMath">\(p_B:A\times_C B\to B\)</span> such that <span class="SimpleMath">\(\comp{p_A}{\pi}\sim \comp{p_B}{\alpha}\)</span> and for any two morphisms <span class="SimpleMath">\(p'_A:T\to A,p'_B:T\to B\)</span> with <span class="SimpleMath">\(\comp{p'_A}{\pi}\sim \comp{p'_B}{\alpha}\)</span>, there exists a unique morphism <span class="SimpleMath">\(u:T\to A\times_C B\)</span> with <span class="SimpleMath">\(\comp{u}{p_A} \sim p'_A\)</span> and <span class="SimpleMath">\(\comp{u}{p_B} \sim p'_B\)</span>.</p>

<p><a id="X7CDE63067EE0779D" name="X7CDE63067EE0779D"></a></p>

<h5>1.2-20 ExactFiberProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactFiberProduct</code>( <var class="Arg">pi</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an object</p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi:A\to C\)</span> and a morphism <span class="SimpleMath">\(\alpha:B\to C\)</span>. The output is the fiber product object <span class="SimpleMath">\(A\times_C B\)</span> of <span class="SimpleMath">\(\pi\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X851EAD8D7C9F259E" name="X851EAD8D7C9F259E"></a></p>

<h5>1.2-21 ProjectionInFirstFactorOfExactFiberProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectionInFirstFactorOfExactFiberProduct</code>( <var class="Arg">pi</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(p_A:A\times_C B\to A\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi:A\to C\)</span> and a morphism <span class="SimpleMath">\(\alpha:B\to C\)</span>. The output is a morphism <span class="SimpleMath">\(p_A:A\times_C B \to A\)</span> which is a part of a fiber product diagram of <span class="SimpleMath">\(\pi\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X802EAF8C784080A2" name="X802EAF8C784080A2"></a></p>

<h5>1.2-22 ProjectionInSecondFactorOfExactFiberProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectionInSecondFactorOfExactFiberProduct</code>( <var class="Arg">pi</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(p_B:A\times_C B\to B\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi:A\to C\)</span> and a morphism <span class="SimpleMath">\(\alpha:B\to C\)</span>. The output is a morphism <span class="SimpleMath">\(p_B:A\times_C B \to B\)</span> which is a part of a fiber product diagram of <span class="SimpleMath">\(\pi\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X7DB5A88F875A92BC" name="X7DB5A88F875A92BC"></a></p>

<h5>1.2-23 UniversalMorphismIntoExactFiberProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UniversalMorphismIntoExactFiberProduct</code>( <var class="Arg">pi</var>, <var class="Arg">alpha</var>, <var class="Arg">pprime_A</var>, <var class="Arg">pprime_B</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(u:T \to A \times_C B\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi:A\to C\)</span> and three morphisms <span class="SimpleMath">\(\alpha:B\to C\)</span>, <span class="SimpleMath">\(p'_A:T\to A\)</span> and <span class="SimpleMath">\(p'_B:T\to B\)</span> such that <span class="SimpleMath">\(\comp{p'_A}{\pi} \sim \comp{p'_B}{\alpha}\)</span>. The output is the universal morphism <span class="SimpleMath">\(u:T\to A\times_C B\)</span> with <span class="SimpleMath">\(\comp{u}{p_A} \sim p'_A\)</span> and <span class="SimpleMath">\(\comp{u}{p_B}\sim p'_B\)</span>.</p>

<p><a id="X7F7BC1C283F5193E" name="X7F7BC1C283F5193E"></a></p>

<h5>1.2-24 <span class="Heading">Exact Pushout</span></h5>

<p>Given an inflation <span class="SimpleMath">\(\iota:C\to A\)</span> and a morphism <span class="SimpleMath">\(\alpha:C\to B\)</span>, an exact pushout diagram of <span class="SimpleMath">\((\iota,\alpha)\)</span> is defined by an object <span class="SimpleMath">\(A\oplus_C B\)</span>, a morphism <span class="SimpleMath">\(q_A:A \to A\oplus_C B\)</span> and an inflation <span class="SimpleMath">\(q_B:B\to A\oplus_C B\)</span> such that <span class="SimpleMath">\(\comp{\iota}{q_A} \sim \comp{\alpha}{q_B}\)</span> and for any two morphisms <span class="SimpleMath">\(q'_A:A\to T,q'_B:B\to T\)</span> with <span class="SimpleMath">\(\comp{\iota}{q'_A}\sim \comp{\alpha}{q'_B}\)</span>, there exists a unique morphism <span class="SimpleMath">\(u: A\oplus_C B \to T\)</span> with <span class="SimpleMath">\(\comp{q_A}{ u}\sim q'_A\)</span> and <span class="SimpleMath">\(\comp{q_B}{ u} \sim q'_B\)</span>.</p>

<p><a id="X7F4025407EBEFCAF" name="X7F4025407EBEFCAF"></a></p>

<h5>1.2-25 ExactPushout</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactPushout</code>( <var class="Arg">iota</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an object</p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota:C\to A\)</span> and a morphism <span class="SimpleMath">\(\alpha:C\to B\)</span>. The output is the pushout object <span class="SimpleMath">\(A\oplus_C B\)</span> of <span class="SimpleMath">\(\iota\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X7DF4981F7DD6E37B" name="X7DF4981F7DD6E37B"></a></p>

<h5>1.2-26 InjectionOfFirstCofactorOfExactPushout</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InjectionOfFirstCofactorOfExactPushout</code>( <var class="Arg">iota</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(A \to A\oplus_C B\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota:C\to A\)</span> and a morphism <span class="SimpleMath">\(\alpha:C\to B\)</span>. The output is a morphism <span class="SimpleMath">\(q_A:A \to A\oplus_C B\)</span> which is a part of a pushout diagram of <span class="SimpleMath">\(\iota\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X7C25B50381FE72D0" name="X7C25B50381FE72D0"></a></p>

<h5>1.2-27 InjectionOfSecondCofactorOfExactPushout</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InjectionOfSecondCofactorOfExactPushout</code>( <var class="Arg">iota</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a inflation <span class="SimpleMath">\(B \to A\oplus_C B\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota:C\to A\)</span> and a morphism <span class="SimpleMath">\(\alpha:C\to B\)</span>. The output is an inflation <span class="SimpleMath">\(q_B:B \to A\oplus_C B\)</span> which is a part of a pushout diagram of <span class="SimpleMath">\(\iota\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X854FA6D97D7228C3" name="X854FA6D97D7228C3"></a></p>

<h5>1.2-28 UniversalMorphismFromExactPushout</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UniversalMorphismFromExactPushout</code>( <var class="Arg">iota</var>, <var class="Arg">alpha</var>, <var class="Arg">qprime_A</var>, <var class="Arg">qprime_B</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(A\oplus_C B \to T\)</span></p>

<p>The arguments are a inflation <span class="SimpleMath">\(\iota:C\to A\)</span> and three morphisms <span class="SimpleMath">\(\alpha:C\to B\)</span>, <span class="SimpleMath">\(q'_A:A\to T\)</span> and <span class="SimpleMath">\(q'_B:B\to T\)</span> such that <span class="SimpleMath">\(\comp{\iota}{ q'_A}\sim \comp{\alpha}{ q'_B}\)</span>. The output is the universal morphism <span class="SimpleMath">\(u:A\oplus_C B\to T\)</span> with <span class="SimpleMath">\(\comp{q_A}{ u}\sim q'_A\)</span> and <span class="SimpleMath">\(\comp{q_B}{u} \sim q'_B\)</span>.</p>

<p><a id="X8365AF0D7CCCF816" name="X8365AF0D7CCCF816"></a></p>

<h5>1.2-29 UniversalMorphismFromExactPushoutWithGivenExactPushout</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UniversalMorphismFromExactPushoutWithGivenExactPushout</code>( <var class="Arg">iota</var>, <var class="Arg">alpha</var>, <var class="Arg">qprime_A</var>, <var class="Arg">qprime_B</var>, <var class="Arg">P</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(P \to T\)</span></p>

<p>The arguments are a inflation <span class="SimpleMath">\(\iota:C\to A\)</span>, three morphisms <span class="SimpleMath">\(\alpha:C\to B\)</span>, <span class="SimpleMath">\(q'_A:A\to T\)</span>, <span class="SimpleMath">\(q'_B:B\to T\)</span> and an object <span class="SimpleMath">\(P=A\oplus_C B=\mathrm{ExactPushout}(\iota,\alpha)\)</span> such that <span class="SimpleMath">\(\comp{\iota}{ q'_A}\sim \comp{\alpha}{ q'_B}\)</span>. The output is the universal morphism <span class="SimpleMath">\(u:P \to T\)</span> with <span class="SimpleMath">\(\comp{q_A}{ u}\sim q'_A\)</span> and <span class="SimpleMath">\(\comp{q_B}{u} \sim q'_B\)</span>.</p>

<p><a id="X851987617A678E7F" name="X851987617A678E7F"></a></p>

<h5>1.2-30 <span class="Heading">Exact Categories With Enough E-projectives</span></h5>

<p>Let <span class="SimpleMath">\((\CC,\EE)\)</span> be an exact category. An object <span class="SimpleMath">\(P\)</span> is called <span class="SimpleMath">\(\mathcal{E}\)</span>-projective if for every morphism <span class="SimpleMath">\(\tau:P\to C\)</span> and every deflation <span class="SimpleMath">\(\pi:B\to C\)</span>, there exists a lift morphism <span class="SimpleMath">\(\lambda:P\to B\)</span> of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\pi\)</span>, i.e., <span class="SimpleMath">\(\comp{\lambda}{\pi}=\tau\)</span>. The exact category <span class="SimpleMath">\((\CC,\EE)\)</span> is said to have enough <span class="SimpleMath">\(\EE\)</span>-projectives if for each object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>, there exists a deflation <span class="SimpleMath">\(p_A:P_A \to A\)</span> where <span class="SimpleMath">\(P_A\)</span> is an <span class="SimpleMath">\(\EE\)</span>-projecitve object.</p>

<p><a id="X7864B1007C32441A" name="X7864B1007C32441A"></a></p>

<h5>1.2-31 IsExactCategoryWithEnoughExactProjectives</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsExactCategoryWithEnoughExactProjectives</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The input is a <strong class="pkg">CAP</strong> category. The output is <code class="code">true</code> if <span class="SimpleMath">\(\CC\)</span> is an exact category with respect to some class <span class="SimpleMath">\(\EE\)</span> of short exact sequences and <span class="SimpleMath">\((\CC,\EE)\)</span> has enough <span class="SimpleMath">\(\EE\)</span>-projectives.</p>

<p><a id="X7F004F3882294703" name="X7F004F3882294703"></a></p>

<h5>1.2-32 IsExactProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsExactProjectiveObject</code>( <var class="Arg">P</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: a boolian</p>

<p>The argument is an object <span class="SimpleMath">\(P\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is whether or not <span class="SimpleMath">\(P\)</span> is an <span class="SimpleMath">\(\EE\)</span>-projective object.</p>

<p><a id="X799EE9F880C76F05" name="X799EE9F880C76F05"></a></p>

<h5>1.2-33 ExactProjectiveLift</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactProjectiveLift</code>( <var class="Arg">tau</var>, <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(\lambda:P\to B\)</span></p>

<p>The arguments are a morphism <span class="SimpleMath">\(\tau:P\to C\)</span> where <span class="SimpleMath">\(P\)</span> is an <span class="SimpleMath">\(\EE\)</span>-projective object and a deflation <span class="SimpleMath">\(\pi:B\to C\)</span>. The output is a lift morphism <span class="SimpleMath">\(\lambda:P\to B\)</span> of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\pi\)</span>, i.e., <span class="SimpleMath">\(\comp{\lambda}{\pi} \sim \tau\)</span>.</p>

<p><a id="X7AB797AA7E467F0A" name="X7AB797AA7E467F0A"></a></p>

<h5>1.2-34 SomeExactProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SomeExactProjectiveObject</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an <span class="SimpleMath">\(\EE\)</span>-projective object</p>

<p>The argument is an object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is an <span class="SimpleMath">\(\EE\)</span>-projective object <span class="SimpleMath">\(P_A\)</span> such that there exists a deflation <span class="SimpleMath">\(P_A \to A\)</span>.</p>

<p><a id="X86313D6E7FB889EC" name="X86313D6E7FB889EC"></a></p>

<h5>1.2-35 DeflationFromSomeExactProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeflationFromSomeExactProjectiveObject</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a deflation <span class="SimpleMath">\(P_A \to A\)</span></p>

<p>The argument is an object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is a deflation morphism <span class="SimpleMath">\(p_A:P_A \to A\)</span> where <span class="SimpleMath">\(P_A = \mathrm{SomeExactProjectiveObject}(A)\)</span>.</p>

<p><a id="X87739A8B7FE89898" name="X87739A8B7FE89898"></a></p>

<h5>1.2-36 <span class="Heading">Exact Categories With Enough E-injecitves</span></h5>

<p>Let <span class="SimpleMath">\((\CC,\EE)\)</span> be an exact category. An object <span class="SimpleMath">\(I\)</span> is called <span class="SimpleMath">\(\mathcal{E}\)</span>-injective if for every inflation <span class="SimpleMath">\(\iota:A\to B\)</span> and every morphism <span class="SimpleMath">\(\tau:A \to I\)</span>, there exists a colift morphism of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\iota\)</span>. The exact category <span class="SimpleMath">\((\CC,\EE)\)</span> is said to have enough <span class="SimpleMath">\(\EE\)</span>-injectives if for each object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>, there exists an inflation <span class="SimpleMath">\(\iota_A:A \to I_A\)</span> where <span class="SimpleMath">\(I_A\)</span> is an <span class="SimpleMath">\(\EE\)</span>-injective object.</p>

<p><a id="X84A9AF9484068AC1" name="X84A9AF9484068AC1"></a></p>

<h5>1.2-37 IsExactCategoryWithEnoughExactInjectives</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsExactCategoryWithEnoughExactInjectives</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The input is a <strong class="pkg">CAP</strong> category. The output is <code class="code">true</code> if <span class="SimpleMath">\(\CC\)</span> is an exact category with respect to some class <span class="SimpleMath">\(\EE\)</span> of short exact sequences and <span class="SimpleMath">\((\CC,\EE)\)</span> has enough <span class="SimpleMath">\(\EE\)</span>-injectives.</p>

<p><a id="X7CAFD3007E885932" name="X7CAFD3007E885932"></a></p>

<h5>1.2-38 IsExactInjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsExactInjectiveObject</code>( <var class="Arg">I</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: a boolian</p>

<p>The argument is an object <span class="SimpleMath">\(I\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is whether or not <span class="SimpleMath">\(I\)</span> is an <span class="SimpleMath">\(\EE\)</span>-injective object.</p>

<p><a id="X7F8F3C02820441DC" name="X7F8F3C02820441DC"></a></p>

<h5>1.2-39 ExactInjectiveColift</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactInjectiveColift</code>( <var class="Arg">iota</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(\lambda:B \to I\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota:A\to B\)</span> and a morphism <span class="SimpleMath">\(\tau:A\to I\)</span> where <span class="SimpleMath">\(I\)</span> is an <span class="SimpleMath">\(\EE\)</span>-injective object. The output is a colift morphism <span class="SimpleMath">\(\lambda:B \to I\)</span> of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\iota\)</span>, i.e., <span class="SimpleMath">\(\comp{\iota}{\lambda} \sim \tau\)</span>.</p>

<p><a id="X869DA05B85F7F112" name="X869DA05B85F7F112"></a></p>

<h5>1.2-40 SomeExactInjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SomeExactInjectiveObject</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an <span class="SimpleMath">\(\EE\)</span>-injective object</p>

<p>The argument is an object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is an <span class="SimpleMath">\(\EE\)</span>-injective object <span class="SimpleMath">\(I_A\)</span> such that there exists an inflation <span class="SimpleMath">\(A \to I_A\)</span>.</p>

<p><a id="X7AD566E9805DA937" name="X7AD566E9805DA937"></a></p>

<h5>1.2-41 InflationIntoSomeExactInjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InflationIntoSomeExactInjectiveObject</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an inflation <span class="SimpleMath">\(A \to I_A\)</span></p>

<p>The argument is an object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is an inflation <span class="SimpleMath">\(\iota_A:A \to I_A\)</span> where <span class="SimpleMath">\(I_A = \mathrm{SomeExactInjectiveObject}(A)\)</span>.</p>

<p><a id="X85E3864B79AE0B00" name="X85E3864B79AE0B00"></a></p>

<h5>1.2-42 IsLiftableAlongDeflationFromSomeExactProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLiftableAlongDeflationFromSomeExactProjectiveObject</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The argument if a morphism <span class="SimpleMath">\(\alpha:A\to B\)</span> in an exact category <span class="SimpleMath">\((\CC,\EE)\)</span> with enough <span class="SimpleMath">\(\EE\)</span>-projectives. The output is whether or not <span class="SimpleMath">\(\alpha\)</span> lifts along <span class="SimpleMath">\(p_B:P_B\to B\)</span> where <span class="SimpleMath">\(p_B=\mathrm{DeflationFromSomeExactProjectiveObject}(B)\)</span>.</p>

<p><a id="X78BDE2BA7950284D" name="X78BDE2BA7950284D"></a></p>

<h5>1.2-43 LiftAlongDeflationFromSomeExactProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftAlongDeflationFromSomeExactProjectiveObject</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The argument is a morphism <span class="SimpleMath">\(\alpha:A\to B\)</span> such that <span class="SimpleMath">\(\alpha\)</span> lifts along <span class="SimpleMath">\(p_B:P_B \to B\)</span> where <span class="SimpleMath">\(p_B=\mathrm{DeflationFromSomeExactProjectiveObject}(B)\)</span>. The output is a lift morphism <span class="SimpleMath">\(\lambda: A \to P_B\)</span> of <span class="SimpleMath">\(\alpha\)</span> along <span class="SimpleMath">\(p_B\)</span>.</p>

<p><a id="X87D53EAB8275CCD8" name="X87D53EAB8275CCD8"></a></p>

<h5>1.2-44 IsColiftableAlongInflationIntoSomeExactInjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsColiftableAlongInflationIntoSomeExactInjectiveObject</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The argument if a morphism <span class="SimpleMath">\(\alpha:A\to B\)</span> in an exact category <span class="SimpleMath">\((\CC,\EE)\)</span> with enough <span class="SimpleMath">\(\EE\)</span>-injectives. The output is whether or not <span class="SimpleMath">\(\alpha\)</span> colifts along <span class="SimpleMath">\(\iota_A:A\to I_A\)</span> where <span class="SimpleMath">\(\iota_A=\mathrm{InflationIntoSomeExactInjectiveObject}(A)\)</span>.</p>

<p><a id="X7E1207BA7C66FAFE" name="X7E1207BA7C66FAFE"></a></p>

<h5>1.2-45 ColiftAlongInflationIntoSomeExactInjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ColiftAlongInflationIntoSomeExactInjectiveObject</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The argument is a morphism <span class="SimpleMath">\(\alpha:A\to B\)</span> such that <span class="SimpleMath">\(\alpha\)</span> colifts along <span class="SimpleMath">\(\iota_A:A \to I_A\)</span> where <span class="SimpleMath">\(\iota_A=\mathrm{InflationIntoSomeExactInjectiveObject}(A)\)</span>. The output is a colift morphism <span class="SimpleMath">\(\lambda: I_A \to B\)</span> of <span class="SimpleMath">\(\alpha\)</span> along <span class="SimpleMath">\(\iota_A\)</span>.</p>

<p><a id="X7E777F887E00910C" name="X7E777F887E00910C"></a></p>

<h5>1.2-46 IsFrobeniusCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFrobeniusCategory</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="keyw">true</code> or <code class="keyw">false</code></p>

<p>The argument is a <strong class="pkg">CAP</strong> category. The output is <code class="code">true</code> if</p>


<ul>
<li><p><span class="SimpleMath">\(\CC\)</span> is exact with respect to some class <span class="SimpleMath">\(\EE\)</span> of short exact sequences,</p>

</li>
<li><p><span class="SimpleMath">\((\CC,\EE)\)</span> has enough <span class="SimpleMath">\(\EE\)</span>-projectives and <span class="SimpleMath">\(\EE\)</span>-injectives,</p>

</li>
<li><p>an object in <span class="SimpleMath">\(\CC\)</span> is <span class="SimpleMath">\(\EE\)</span>-projective if and only if it is <span class="SimpleMath">\(\EE\)</span>-injective.</p>

</li>
</ul>
<p><a id="X806A08297D4DE852" name="X806A08297D4DE852"></a></p>

<h5>1.2-47 SchanuelsIsomorphismByInflationsIntoSomeExactInjectiveObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SchanuelsIsomorphismByInflationsIntoSomeExactInjectiveObjects</code>( <var class="Arg">i</var>, <var class="Arg">s</var>, <var class="Arg">j</var>, <var class="Arg">t</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The arguments are an inflation <span class="SimpleMath">\(i:A\to I\)</span>, a deflation <span class="SimpleMath">\(s:I \to B\)</span>, an inflation <span class="SimpleMath">\(j:A \to J\)</span>, a deflation <span class="SimpleMath">\(t: J \to C\)</span> in an exact category <span class="SimpleMath">\((\CC,\EE)\)</span> such that <span class="SimpleMath">\(I\)</span> and <span class="SimpleMath">\(J\)</span> are <span class="SimpleMath">\(\EE\)</span>-injective objects and the pairs <span class="SimpleMath">\((i,s)\)</span> and <span class="SimpleMath">\((j,t)\)</span> are conflations. The output is a morphism <span class="SimpleMath">\(u: B \to C\)</span> such that <span class="SimpleMath">\(u\)</span> becomes an isomorphism in the stable category of <span class="SimpleMath">\(\CC\)</span> by the class of exact injective objects.</p>

<p><a id="X870156627E385E31" name="X870156627E385E31"></a></p>

<h5>1.2-48 SchanuelsIsomorphismByDeflationsFromSomeExactProjectiveObjects</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SchanuelsIsomorphismByDeflationsFromSomeExactProjectiveObjects</code>( <var class="Arg">i</var>, <var class="Arg">s</var>, <var class="Arg">j</var>, <var class="Arg">t</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The arguments are an inflation <span class="SimpleMath">\(i:A\to I\)</span>, a deflation <span class="SimpleMath">\(s:I \to C\)</span>, an inflation <span class="SimpleMath">\(j:B \to J\)</span>, a deflation <span class="SimpleMath">\(t: J \to C\)</span> in an exact category <span class="SimpleMath">\((\CC,\EE)\)</span> such that <span class="SimpleMath">\(I\)</span> and <span class="SimpleMath">\(J\)</span> are <span class="SimpleMath">\(\EE\)</span>-projective objects and the pairs <span class="SimpleMath">\((i,s)\)</span> and <span class="SimpleMath">\((j,t)\)</span> are conflations. The output is a morphism <span class="SimpleMath">\(u: A \to B\)</span> such that <span class="SimpleMath">\(u\)</span> becomes an isomorphism in the stable category of <span class="SimpleMath">\(\CC\)</span> by the class of exact projective objects.</p>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
