<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (StableCategories) - Chapter 1: Exact and Frobenius Categories</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap1"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap1.html">[MathJax off]</a></p>
<p><a id="X806FCA1E826CB3DC" name="X806FCA1E826CB3DC"></a></p>
<div class="ChapSects"><a href="chap1_mj.html#X806FCA1E826CB3DC">1 <span class="Heading">Exact and Frobenius Categories</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7D03633A7D98026B">1.1 <span class="Heading">GAP categories</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8218A4C07B347D6D">1.1-1 IsCapCategoryShortSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7C7383557981C69C">1.1-2 IsCapCategoryMorphismOfShortSequences</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CA59D1E7DADD783">1.1-3 IsCapCategoryShortExactSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X788847887B6F8217">1.1-4 IsCapCategoryConflation</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap1_mj.html#X7C68BE597DB754B6">1.2 <span class="Heading">Exact categories operations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7B52F7A5834F4772">1.2-1 IsExactCategory</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7811C3CE8142333A">1.2-2 IsInflation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X79EB8A527CBFA27F">1.2-3 IsDeflation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7E737AA87E04F8EA">1.2-4 IsConflationPair</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7BE431ED81B81D8D">1.2-5 ExactCokernelObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7EDF6125848C51F5">1.2-6 ExactCokernelProjection</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8447687F839F3231">1.2-7 ExactCokernelProjectionWithGivenExactCokernelObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CC1AA4D7D5A4564">1.2-8 ExactCokernelColift</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X83755C2686E92DB4">1.2-9 ColiftAlongDeflation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X82A7834B7BB4C336">1.2-10 ExactKernelObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X857917A17F7D5DE4">1.2-11 ExactKernelEmbedding</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8713CEEE7E0E31E1">1.2-12 ExactKernelEmbeddingWithGivenExactKernelObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8763D19680624B26">1.2-13 ExactKernelLift</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8116CB597B2A3970">1.2-14 LiftAlongInflation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7A36F1517EB22248">1.2-15 <span class="Heading">Exact Fiber Product</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CDE63067EE0779D">1.2-16 ExactFiberProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X851EAD8D7C9F259E">1.2-17 ProjectionInFirstFactorOfExactFiberProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X802EAF8C784080A2">1.2-18 ProjectionInSecondFactorOfExactFiberProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7DB5A88F875A92BC">1.2-19 UniversalMorphismIntoExactFiberProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7F7BC1C283F5193E">1.2-20 <span class="Heading">Exact Pushout</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7F4025407EBEFCAF">1.2-21 ExactPushout</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7DF4981F7DD6E37B">1.2-22 InjectionOfFirstCofactorOfExactPushout</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7C25B50381FE72D0">1.2-23 InjectionOfSecondCofactorOfExactPushout</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X854FA6D97D7228C3">1.2-24 UniversalMorphismFromExactPushout</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X8365AF0D7CCCF816">1.2-25 UniversalMorphismFromExactPushoutWithGivenExactPushout</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X851987617A678E7F">1.2-26 <span class="Heading">Exact Categories With Enough E-projectives</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7864B1007C32441A">1.2-27 IsExactCategoryWithEnoughExactProjectives</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7F004F3882294703">1.2-28 IsExactProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X799EE9F880C76F05">1.2-29 ExactProjectiveLift</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7AB797AA7E467F0A">1.2-30 SomeExactProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X86313D6E7FB889EC">1.2-31 DeflationFromSomeExactProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X87739A8B7FE89898">1.2-32 <span class="Heading">Exact Categories With Enough E-injecitves</span></a>
</span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X84A9AF9484068AC1">1.2-33 IsExactCategoryWithEnoughExactInjectives</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7CAFD3007E885932">1.2-34 IsExactInjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7F8F3C02820441DC">1.2-35 ExactInjectiveColift</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X869DA05B85F7F112">1.2-36 SomeExactInjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7AD566E9805DA937">1.2-37 InflationIntoSomeExactInjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X85E3864B79AE0B00">1.2-38 IsLiftableAlongDeflationFromSomeExactProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X78BDE2BA7950284D">1.2-39 LiftAlongDeflationFromSomeExactProjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X87D53EAB8275CCD8">1.2-40 IsColiftableAlongInflationIntoSomeExactInjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7E1207BA7C66FAFE">1.2-41 ColiftAlongInflationIntoSomeExactInjectiveObject</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap1_mj.html#X7E777F887E00910C">1.2-42 IsFrobeniusCategory</a></span>
</div></div>
</div>

<h3>1 <span class="Heading">Exact and Frobenius Categories</span></h3>

<p><a id="X7D03633A7D98026B" name="X7D03633A7D98026B"></a></p>

<h4>1.1 <span class="Heading">GAP categories</span></h4>

<p><a id="X8218A4C07B347D6D" name="X8218A4C07B347D6D"></a></p>

<h5>1.1-1 IsCapCategoryShortSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCapCategoryShortSequence</code>( <var class="Arg">seq_obj</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of short sequences.</p>

<p><a id="X7C7383557981C69C" name="X7C7383557981C69C"></a></p>

<h5>1.1-2 IsCapCategoryMorphismOfShortSequences</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCapCategoryMorphismOfShortSequences</code>( <var class="Arg">seq_mor</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of morphisms of short sequences.</p>

<p><a id="X7CA59D1E7DADD783" name="X7CA59D1E7DADD783"></a></p>

<h5>1.1-3 IsCapCategoryShortExactSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCapCategoryShortExactSequence</code>( <var class="Arg">seq_obj</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of short exact sequences.</p>

<p><a id="X788847887B6F8217" name="X788847887B6F8217"></a></p>

<h5>1.1-4 IsCapCategoryConflation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsCapCategoryConflation</code>( <var class="Arg">seq_obj</var> )</td><td class="tdright">(&nbsp;filter&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p>The <strong class="pkg">GAP</strong> category of conflations. If a short sequence is a conflation, then it is a short exact sequence.</p>

<p><a id="X7C68BE597DB754B6" name="X7C68BE597DB754B6"></a></p>

<h4>1.2 <span class="Heading">Exact categories operations</span></h4>

<p><a id="X7B52F7A5834F4772" name="X7B52F7A5834F4772"></a></p>

<h5>1.2-1 IsExactCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsExactCategory</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p>The input is a <strong class="pkg">CAP</strong> category. The output is <code class="code">true</code> if <span class="SimpleMath">\(\CC\)</span> is an exact category with respect to some class <span class="SimpleMath">\(\EE\)</span> of short exact sequences.</p>

<p><a id="X7811C3CE8142333A" name="X7811C3CE8142333A"></a></p>

<h5>1.2-2 IsInflation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsInflation</code>( <var class="Arg">iota</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a boolian</p>

<p>The argument is a morphism <span class="SimpleMath">\(\iota:A\to B\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is whether or not <span class="SimpleMath">\(\iota\)</span> is an inflation.</p>

<p><a id="X79EB8A527CBFA27F" name="X79EB8A527CBFA27F"></a></p>

<h5>1.2-3 IsDeflation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsDeflation</code>( <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a boolian</p>

<p>The argument is a morphism <span class="SimpleMath">\(\pi:B\to C\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is whether or not <span class="SimpleMath">\(\pi\)</span> is a deflation.</p>

<p><a id="X7E737AA87E04F8EA" name="X7E737AA87E04F8EA"></a></p>

<h5>1.2-4 IsConflationPair</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsConflationPair</code>( <var class="Arg">iota</var>, <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a boolian</p>

<p>The argument is a pair of morphisms <span class="SimpleMath">\(\iota:A\to B\)</span> and <span class="SimpleMath">\(\pi:B\to C\)</span>. The output is whether or not the pair <span class="SimpleMath">\((\iota,\pi)\)</span> defines a conflation.</p>

<p><a id="X7BE431ED81B81D8D" name="X7BE431ED81B81D8D"></a></p>

<h5>1.2-5 ExactCokernelObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactCokernelObject</code>( <var class="Arg">iota</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an object <span class="SimpleMath">\(C\)</span></p>

<p>The argument is an inflation <span class="SimpleMath">\(\iota:A\to B\)</span>. The output is the cokernel object <span class="SimpleMath">\(C\)</span> of <span class="SimpleMath">\(\iota\)</span>.</p>

<p><a id="X7EDF6125848C51F5" name="X7EDF6125848C51F5"></a></p>

<h5>1.2-6 ExactCokernelProjection</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactCokernelProjection</code>( <var class="Arg">iota</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a deflation <span class="SimpleMath">\(B\to C\)</span></p>

<p>The argument is an inflation <span class="SimpleMath">\(\iota:A\to B\)</span>. The output is a deflation <span class="SimpleMath">\(\pi(\iota):B\to C\)</span> with <span class="SimpleMath">\(C=\mathrm{ExactCokernelObject}(\iota)\)</span> such that the pair <span class="SimpleMath">\((\iota,\pi(\iota))\)</span> defines a conflation.</p>

<p><a id="X8447687F839F3231" name="X8447687F839F3231"></a></p>

<h5>1.2-7 ExactCokernelProjectionWithGivenExactCokernelObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactCokernelProjectionWithGivenExactCokernelObject</code>( <var class="Arg">iota</var>, <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a deflation <span class="SimpleMath">\(B\to C\)</span></p>

<p>The argument is an inflation <span class="SimpleMath">\(\iota:A\to B\)</span> and an object <span class="SimpleMath">\(C=\mathrm{ExactCokernelObject}(\iota)\)</span>. The output is a deflation <span class="SimpleMath">\(\pi(\iota):B\to C\)</span> such that <span class="SimpleMath">\((\iota,\pi(\iota))\)</span> defines a conflation.</p>

<p><a id="X7CC1AA4D7D5A4564" name="X7CC1AA4D7D5A4564"></a></p>

<h5>1.2-8 ExactCokernelColift</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactCokernelColift</code>( <var class="Arg">iota</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(C \to T\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota: A \rightarrow B\)</span> and a test morphism <span class="SimpleMath">\(\tau: B \rightarrow T\)</span> satisfying <span class="SimpleMath">\(\comp{\iota}{\tau} \sim 0\)</span>. The output is the morphism <span class="SimpleMath">\(\lambda: C \rightarrow T\)</span> with <span class="SimpleMath">\(C=\mathrm{ExactCokernelObject}(\iota)\)</span> and <span class="SimpleMath">\(\lambda\)</span> is given by the universal property of the cokernel object, i.e., <span class="SimpleMath">\(\comp{\pi(\iota)}{\lambda} \sim \tau\)</span> where <span class="SimpleMath">\(\pi(\iota) = \mathrm{ExactCokernelProjection}(\iota)\)</span>.</p>

<p><a id="X83755C2686E92DB4" name="X83755C2686E92DB4"></a></p>

<h5>1.2-9 ColiftAlongDeflation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ColiftAlongDeflation</code>( <var class="Arg">pi</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(C \to T\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi: B \rightarrow C\)</span> and a morphism <span class="SimpleMath">\(\tau: B \to T\)</span> such that <span class="SimpleMath">\(\tau\)</span> is coliftable along <span class="SimpleMath">\(\pi\)</span>. That is, <span class="SimpleMath">\(\comp{\iota(\pi)}{\tau} \sim 0\)</span>. The output is the unique colift morphism <span class="SimpleMath">\(\lambda:C\to T\)</span> of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\pi\)</span>.</p>

<p><a id="X82A7834B7BB4C336" name="X82A7834B7BB4C336"></a></p>

<h5>1.2-10 ExactKernelObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactKernelObject</code>( <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an object <span class="SimpleMath">\(K\)</span></p>

<p>The argument is a deflation <span class="SimpleMath">\(\pi:B\to C\)</span>. The output is the kernel object <span class="SimpleMath">\(K\)</span> of <span class="SimpleMath">\(\pi\)</span>.</p>

<p><a id="X857917A17F7D5DE4" name="X857917A17F7D5DE4"></a></p>

<h5>1.2-11 ExactKernelEmbedding</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactKernelEmbedding</code>( <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an inflation <span class="SimpleMath">\(K\to B\)</span></p>

<p>The argument is a deflation <span class="SimpleMath">\(\pi:B\to C\)</span>. The output is an inflation <span class="SimpleMath">\(\iota(\pi):K\to B\)</span> with <span class="SimpleMath">\(K=\mathrm{ExactKernelObject}(\pi)\)</span> such that the pair <span class="SimpleMath">\((\iota(\pi),\pi)\)</span> defines a conflation.</p>

<p><a id="X8713CEEE7E0E31E1" name="X8713CEEE7E0E31E1"></a></p>

<h5>1.2-12 ExactKernelEmbeddingWithGivenExactKernelObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactKernelEmbeddingWithGivenExactKernelObject</code>( <var class="Arg">pi</var>, <var class="Arg">K</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an inflation <span class="SimpleMath">\(K\to B\)</span></p>

<p>The argument is a deflation <span class="SimpleMath">\(\pi:B\to C\)</span> and an object <span class="SimpleMath">\(K=\mathrm{ExactKernelObject}(\pi)\)</span>. The output is an inflation <span class="SimpleMath">\(\iota(\pi):K\to B\)</span> such that the pair <span class="SimpleMath">\((\iota(\pi),\pi)\)</span> defines a conflation.</p>

<p><a id="X8763D19680624B26" name="X8763D19680624B26"></a></p>

<h5>1.2-13 ExactKernelLift</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactKernelLift</code>( <var class="Arg">pi</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(T \to K\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi: B \rightarrow C\)</span> and a test morphism <span class="SimpleMath">\(\tau: T \rightarrow B\)</span> satisfying <span class="SimpleMath">\(\comp{\tau}{\pi} \sim 0\)</span>. The output is the morphism <span class="SimpleMath">\(\lambda: T \rightarrow K\)</span> with <span class="SimpleMath">\(K=\mathrm{ExactKernelObject}(\pi)\)</span> and <span class="SimpleMath">\(\lambda\)</span> is given by the universal property of the kernel object, i.e., <span class="SimpleMath">\(\comp{\lambda}{\iota(\pi)} \sim \tau\)</span> where <span class="SimpleMath">\(\iota(\pi) = \mathrm{ExactKernelEmbedding}(\pi)\)</span>.</p>

<p><a id="X8116CB597B2A3970" name="X8116CB597B2A3970"></a></p>

<h5>1.2-14 LiftAlongInflation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftAlongInflation</code>( <var class="Arg">iota</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(C \to T\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota: A \rightarrow B\)</span> and a morphism <span class="SimpleMath">\(\tau: T \to B\)</span> such that <span class="SimpleMath">\(\tau\)</span> is liftable along <span class="SimpleMath">\(\iota\)</span>. That is, <span class="SimpleMath">\(\comp{\tau}{\pi(\iota)} \sim 0\)</span>. The output is the unique lift morphism <span class="SimpleMath">\(\lambda:T\to A\)</span> of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\iota\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationalsInSingular( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EEE := KoszulDualRing( GradedRing( Q * "x,y" ) );</span>
Q{e0,e1}
(weights: [ -1, -1 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Grows_E := CategoryOfGradedRows( EEE );</span>
Graded rows( Q{e0,e1} (with weights [ -1, -1 ]) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Grmod_E := FreydCategory( Grows_E );</span>
Category of f.p. graded left modules over Q{e0,e1} (with weights [ -1, -1 ])
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsExactCategory( Grmod_E );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sU := GradedRow( [ [ [1], 2 ] ], EEE );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rU := GradedRow( [ [ [0], 2 ] ], EEE );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mU := HomalgMatrix( "[[2*e0,4*e0+e1],[-e0+e1,-e0]]", 2, 2, EEE );</span>
&lt;A 2 x 2 matrix over a graded ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := GradedRowOrColumnMorphism( sU, mU, rU ) / Grmod_E;</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( U );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sV := GradedRow( [ [ [1], 1 ], [ [0], 1 ] ], EEE );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rV := GradedRow( [ [ [-1], 1 ], [ [0], 1 ] ], EEE );</span>
&lt;A graded row of rank 2&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mV := HomalgMatrix( "[[0,-2*e0],[e0+e1,0]]", 2, 2, EEE );</span>
&lt;A 2 x 2 matrix over a graded ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V := GradedRowOrColumnMorphism( sV, mV, rV ) / Grmod_E;</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( V );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mat := HomalgMatrix( "[[-e1,0],[-e1,0]]", 2, 2, EEE );</span>
&lt;A 2 x 2 matrix over a graded ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu := GradedRowOrColumnMorphism( rU, mat, rV );</span>
&lt;A morphism in Category of graded rows over Q{e0,e1} (with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">mu := FreydCategoryMorphism( U, mu, V );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( mu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConflationPair( ExactKernelEmbedding( mu ), mu );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConflationPair( mu, ExactCokernelProjection( mu ) );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota := KernelEmbedding( mu );</span>
&lt;A monomorphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi_iota := ExactCokernelProjection( iota );</span>
&lt;An epimorphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConflationPair( iota, pi_iota );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := CokernelProjection( mu );</span>
&lt;An epimorphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota_pi := ExactKernelEmbedding( pi );</span>
&lt;A monomorphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConflationPair( iota_pi, pi );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lambda := ExactCokernelColift( iota, mu );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( pi_iota, lambda ), mu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lambda := ExactKernelLift( pi, mu );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lambda, iota_pi ), mu );</span>
true
</pre></div>

<p><a id="X7A36F1517EB22248" name="X7A36F1517EB22248"></a></p>

<h5>1.2-15 <span class="Heading">Exact Fiber Product</span></h5>

<p>Given a deflation <span class="SimpleMath">\(\pi:A\to C\)</span> and a morphism <span class="SimpleMath">\(\alpha:B\to C\)</span>, an exact fiber product diagram of <span class="SimpleMath">\((\pi,\alpha)\)</span> is defined by an object <span class="SimpleMath">\(A\times_C B\)</span>, a morphism <span class="SimpleMath">\(p_A:A\times_C B\to A\)</span> and a deflation <span class="SimpleMath">\(p_B:A\times_C B\to B\)</span> such that <span class="SimpleMath">\(\comp{p_A}{\pi}\sim \comp{p_B}{\alpha}\)</span> and for any two morphisms <span class="SimpleMath">\(p'_A:T\to A,p'_B:T\to B\)</span> with <span class="SimpleMath">\(\comp{p'_A}{\pi}\sim \comp{p'_B}{\alpha}\)</span>, there exists a unique morphism <span class="SimpleMath">\(u:T\to A\times_C B\)</span> with <span class="SimpleMath">\(\comp{u}{p_A} \sim p'_A\)</span> and <span class="SimpleMath">\(\comp{u}{p_B} \sim p'_B\)</span>.</p>

<p><a id="X7CDE63067EE0779D" name="X7CDE63067EE0779D"></a></p>

<h5>1.2-16 ExactFiberProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactFiberProduct</code>( <var class="Arg">pi</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an object</p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi:A\to C\)</span> and a morphism <span class="SimpleMath">\(\alpha:B\to C\)</span>. The output is the fiber product object <span class="SimpleMath">\(A\times_C B\)</span> of <span class="SimpleMath">\(\pi\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X851EAD8D7C9F259E" name="X851EAD8D7C9F259E"></a></p>

<h5>1.2-17 ProjectionInFirstFactorOfExactFiberProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectionInFirstFactorOfExactFiberProduct</code>( <var class="Arg">pi</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(p_A:A\times_C B\to A\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi:A\to C\)</span> and a morphism <span class="SimpleMath">\(\alpha:B\to C\)</span>. The output is a morphism <span class="SimpleMath">\(p_A:A\times_C B \to A\)</span> which is a part of a fiber product diagram of <span class="SimpleMath">\(\pi\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X802EAF8C784080A2" name="X802EAF8C784080A2"></a></p>

<h5>1.2-18 ProjectionInSecondFactorOfExactFiberProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ProjectionInSecondFactorOfExactFiberProduct</code>( <var class="Arg">pi</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(p_B:A\times_C B\to B\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi:A\to C\)</span> and a morphism <span class="SimpleMath">\(\alpha:B\to C\)</span>. The output is a morphism <span class="SimpleMath">\(p_B:A\times_C B \to B\)</span> which is a part of a fiber product diagram of <span class="SimpleMath">\(\pi\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X7DB5A88F875A92BC" name="X7DB5A88F875A92BC"></a></p>

<h5>1.2-19 UniversalMorphismIntoExactFiberProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UniversalMorphismIntoExactFiberProduct</code>( <var class="Arg">pi</var>, <var class="Arg">alpha</var>, <var class="Arg">pprime_A</var>, <var class="Arg">pprime_B</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(u:T \to A \times_C B\)</span></p>

<p>The arguments are a deflation <span class="SimpleMath">\(\pi:A\to C\)</span> and three morphisms <span class="SimpleMath">\(\alpha:B\to C\)</span>, <span class="SimpleMath">\(p'_A:T\to A\)</span> and <span class="SimpleMath">\(p'_B:T\to B\)</span> such that <span class="SimpleMath">\(\comp{p'_A}{\pi} \sim \comp{p'_B}{\alpha}\)</span>. The output is the universal morphism <span class="SimpleMath">\(u:T\to A\times_C B\)</span> with <span class="SimpleMath">\(\comp{u}{p_A} \sim p'_A\)</span> and <span class="SimpleMath">\(\comp{u}{p_B}\sim p'_B\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := mu;</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Source( alpha );</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := Range( alpha );</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismFromSomeProjectiveObject( C );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p_A := ProjectionInFirstFactorOfExactFiberProduct( pi, alpha );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p_B := ProjectionInSecondFactorOfExactFiberProduct( pi, alpha );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( p_A, pi ), PreCompose( p_B, alpha ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pprime_B := EpimorphismFromSomeProjectiveObject( B );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pprime_A := ProjectiveLift( PreCompose( pprime_B, alpha ), pi );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      PreCompose( pprime_A, pi ), PreCompose( pprime_B, alpha )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := UniversalMorphismIntoExactFiberProduct( pi, alpha, pprime_A, pprime_B );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( u, p_B ), pprime_B );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( u, p_A ), pprime_A );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( u );</span>
false
</pre></div>

<p><a id="X7F7BC1C283F5193E" name="X7F7BC1C283F5193E"></a></p>

<h5>1.2-20 <span class="Heading">Exact Pushout</span></h5>

<p>Given an inflation <span class="SimpleMath">\(\iota:C\to A\)</span> and a morphism <span class="SimpleMath">\(\alpha:C\to B\)</span>, an exact pushout diagram of <span class="SimpleMath">\((\iota,\alpha)\)</span> is defined by an object <span class="SimpleMath">\(A\oplus_C B\)</span>, a morphism <span class="SimpleMath">\(q_A:A \to A\oplus_C B\)</span> and an inflation <span class="SimpleMath">\(q_B:B\to A\oplus_C B\)</span> such that <span class="SimpleMath">\(\comp{\iota}{q_A} \sim \comp{\alpha}{q_B}\)</span> and for any two morphisms <span class="SimpleMath">\(q'_A:A\to T,q'_B:B\to T\)</span> with <span class="SimpleMath">\(\comp{\iota}{q'_A}\sim \comp{\alpha}{q'_B}\)</span>, there exists a unique morphism <span class="SimpleMath">\(u: A\oplus_C B \to T\)</span> with <span class="SimpleMath">\(\comp{q_A}{ u}\sim q'_A\)</span> and <span class="SimpleMath">\(\comp{q_B}{ u} \sim q'_B\)</span>.</p>

<p><a id="X7F4025407EBEFCAF" name="X7F4025407EBEFCAF"></a></p>

<h5>1.2-21 ExactPushout</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactPushout</code>( <var class="Arg">iota</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an object</p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota:C\to A\)</span> and a morphism <span class="SimpleMath">\(\alpha:C\to B\)</span>. The output is the pushout object <span class="SimpleMath">\(A\oplus_C B\)</span> of <span class="SimpleMath">\(\iota\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X7DF4981F7DD6E37B" name="X7DF4981F7DD6E37B"></a></p>

<h5>1.2-22 InjectionOfFirstCofactorOfExactPushout</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InjectionOfFirstCofactorOfExactPushout</code>( <var class="Arg">iota</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(A \to A\oplus_C B\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota:C\to A\)</span> and a morphism <span class="SimpleMath">\(\alpha:C\to B\)</span>. The output is a morphism <span class="SimpleMath">\(q_A:A \to A\oplus_C B\)</span> which is a part of a pushout diagram of <span class="SimpleMath">\(\iota\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X7C25B50381FE72D0" name="X7C25B50381FE72D0"></a></p>

<h5>1.2-23 InjectionOfSecondCofactorOfExactPushout</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InjectionOfSecondCofactorOfExactPushout</code>( <var class="Arg">iota</var>, <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a inflation <span class="SimpleMath">\(B \to A\oplus_C B\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota:C\to A\)</span> and a morphism <span class="SimpleMath">\(\alpha:C\to B\)</span>. The output is an inflation <span class="SimpleMath">\(q_B:B \to A\oplus_C B\)</span> which is a part of a pushout diagram of <span class="SimpleMath">\(\iota\)</span> and <span class="SimpleMath">\(\alpha\)</span>.</p>

<p><a id="X854FA6D97D7228C3" name="X854FA6D97D7228C3"></a></p>

<h5>1.2-24 UniversalMorphismFromExactPushout</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UniversalMorphismFromExactPushout</code>( <var class="Arg">iota</var>, <var class="Arg">alpha</var>, <var class="Arg">qprime_A</var>, <var class="Arg">qprime_B</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(A\oplus_C B \to T\)</span></p>

<p>The arguments are a inflation <span class="SimpleMath">\(\iota:C\to A\)</span> and three morphisms <span class="SimpleMath">\(\alpha:C\to B\)</span>, <span class="SimpleMath">\(q'_A:A\to T\)</span> and <span class="SimpleMath">\(q'_B:B\to T\)</span> such that <span class="SimpleMath">\(\comp{\iota}{ q'_A}\sim \comp{\alpha}{ q'_B}\)</span>. The output is the universal morphism <span class="SimpleMath">\(u:A\oplus_C B\to T\)</span> with <span class="SimpleMath">\(\comp{q_A}{ u}\sim q'_A\)</span> and <span class="SimpleMath">\(\comp{q_B}{u} \sim q'_B\)</span>.</p>

<p><a id="X8365AF0D7CCCF816" name="X8365AF0D7CCCF816"></a></p>

<h5>1.2-25 UniversalMorphismFromExactPushoutWithGivenExactPushout</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UniversalMorphismFromExactPushoutWithGivenExactPushout</code>( <var class="Arg">iota</var>, <var class="Arg">alpha</var>, <var class="Arg">qprime_A</var>, <var class="Arg">qprime_B</var>, <var class="Arg">P</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(P \to T\)</span></p>

<p>The arguments are a inflation <span class="SimpleMath">\(\iota:C\to A\)</span>, three morphisms <span class="SimpleMath">\(\alpha:C\to B\)</span>, <span class="SimpleMath">\(q'_A:A\to T\)</span>, <span class="SimpleMath">\(q'_B:B\to T\)</span> and an object <span class="SimpleMath">\(P=A\oplus_C B=\mathrm{ExactPushout}(\iota,\alpha)\)</span> such that <span class="SimpleMath">\(\comp{\iota}{ q'_A}\sim \comp{\alpha}{ q'_B}\)</span>. The output is the universal morphism <span class="SimpleMath">\(u:P \to T\)</span> with <span class="SimpleMath">\(\comp{q_A}{ u}\sim q'_A\)</span> and <span class="SimpleMath">\(\comp{q_B}{u} \sim q'_B\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := mu;</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Source( alpha );</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := Range( alpha );</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := EpimorphismFromSomeProjectiveObject( C );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p_A := ProjectionInFirstFactorOfExactFiberProduct( pi, alpha );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p_B := ProjectionInSecondFactorOfExactFiberProduct( pi, alpha );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( p_A, pi ), PreCompose( p_B, alpha ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pprime_B := EpimorphismFromSomeProjectiveObject( B );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pprime_A := ProjectiveLift( PreCompose( pprime_B, alpha ), pi );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      PreCompose( pprime_A, pi ), PreCompose( pprime_B, alpha )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := UniversalMorphismIntoExactFiberProduct( pi, alpha, pprime_A, pprime_B );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( u, p_B ), pprime_B );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( u, p_A ), pprime_A );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( u );</span>
false
</pre></div>

<p><a id="X851987617A678E7F" name="X851987617A678E7F"></a></p>

<h5>1.2-26 <span class="Heading">Exact Categories With Enough E-projectives</span></h5>

<p>Let <span class="SimpleMath">\((\CC,\EE)\)</span> be an exact category. An object <span class="SimpleMath">\(P\)</span> is called <span class="SimpleMath">\(\mathcal{E}\)</span>-projective if for every morphism <span class="SimpleMath">\(\tau:P\to C\)</span> and every deflation <span class="SimpleMath">\(\pi:B\to C\)</span>, there exists a lift morphism <span class="SimpleMath">\(\lambda:P\to B\)</span> of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\pi\)</span>, i.e., <span class="SimpleMath">\(\comp{\lambda}{\pi}=\tau\)</span>. The exact category <span class="SimpleMath">\((\CC,\EE)\)</span> is said to have enough <span class="SimpleMath">\(\EE\)</span>-projectives if for each object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>, there exists a deflation <span class="SimpleMath">\(p_A:P_A \to A\)</span> where <span class="SimpleMath">\(P_A\)</span> is an <span class="SimpleMath">\(\EE\)</span>-projecitve object.</p>

<p><a id="X7864B1007C32441A" name="X7864B1007C32441A"></a></p>

<h5>1.2-27 IsExactCategoryWithEnoughExactProjectives</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsExactCategoryWithEnoughExactProjectives</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p>The input is a <strong class="pkg">CAP</strong> category. The output is <code class="code">true</code> if <span class="SimpleMath">\(\CC\)</span> is an exact category with respect to some class <span class="SimpleMath">\(\EE\)</span> of short exact sequences and <span class="SimpleMath">\((\CC,\EE)\)</span> has enough <span class="SimpleMath">\(\EE\)</span>-projectives.</p>

<p><a id="X7F004F3882294703" name="X7F004F3882294703"></a></p>

<h5>1.2-28 IsExactProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsExactProjectiveObject</code>( <var class="Arg">P</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: a boolian</p>

<p>The argument is an object <span class="SimpleMath">\(P\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is whether or not <span class="SimpleMath">\(P\)</span> is an <span class="SimpleMath">\(\EE\)</span>-projective object.</p>

<p><a id="X799EE9F880C76F05" name="X799EE9F880C76F05"></a></p>

<h5>1.2-29 ExactProjectiveLift</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactProjectiveLift</code>( <var class="Arg">tau</var>, <var class="Arg">pi</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(\lambda:P\to B\)</span></p>

<p>The arguments are a morphism <span class="SimpleMath">\(\tau:P\to C\)</span> where <span class="SimpleMath">\(P\)</span> is an <span class="SimpleMath">\(\EE\)</span>-projective object and a deflation <span class="SimpleMath">\(\pi:B\to C\)</span>. The output is a lift morphism <span class="SimpleMath">\(\lambda:P\to B\)</span> of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\pi\)</span>, i.e., <span class="SimpleMath">\(\comp{\lambda}{\pi} \sim \tau\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi := CokernelProjection( mu );</span>
&lt;An epimorphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConflationPair( ExactKernelEmbedding( pi ), pi );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := Range( pi );</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1} 
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := GradedRow( [ [ [0], 2 ], [ [1], 1 ] ], EEE );</span>
&lt;A graded row of rank 3&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P := AsFreydCategoryObject( P );</span>
&lt;A projective object in Category of f.p. graded left modules over Q{e0,e1} 
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsExactProjectiveObject( P );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hom_PC := BasisOfExternalHom( P, C );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( Hom_PC );</span>
3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tau := Random( Hom_PC );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lambda := ExactProjectiveLift( tau, pi );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lambda, pi ), tau );</span>
true
</pre></div>

<p><a id="X7AB797AA7E467F0A" name="X7AB797AA7E467F0A"></a></p>

<h5>1.2-30 SomeExactProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SomeExactProjectiveObject</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: an <span class="SimpleMath">\(\EE\)</span>-projective object</p>

<p>The argument is an object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is an <span class="SimpleMath">\(\EE\)</span>-projective object <span class="SimpleMath">\(P_A\)</span> such that there exists a deflation <span class="SimpleMath">\(P_A \to A\)</span>.</p>

<p><a id="X86313D6E7FB889EC" name="X86313D6E7FB889EC"></a></p>

<h5>1.2-31 DeflationFromSomeExactProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DeflationFromSomeExactProjectiveObject</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>Returns: a deflation <span class="SimpleMath">\(P_A \to A\)</span></p>

<p>The argument is an object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is a deflation morphism <span class="SimpleMath">\(p_A:P_A \to A\)</span> where <span class="SimpleMath">\(P_A = \mathrm{SomeExactProjectiveObject}(A)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsExactCategoryWithEnoughExactProjectives( Grmod_E );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V;</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P_V := SomeExactProjectiveObject( U );</span>
&lt;A projective object in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsExactProjectiveObject( P_V );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi_V := DeflationFromSomeExactProjectiveObject( V );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConflationPair( ExactKernelEmbedding( pi_V ), pi_V );</span>
true
</pre></div>

<p><a id="X87739A8B7FE89898" name="X87739A8B7FE89898"></a></p>

<h5>1.2-32 <span class="Heading">Exact Categories With Enough E-injecitves</span></h5>

<p>Let <span class="SimpleMath">\((\CC,\EE)\)</span> be an exact category. An object <span class="SimpleMath">\(I\)</span> is called <span class="SimpleMath">\(\mathcal{E}\)</span>-injective if for every inflation <span class="SimpleMath">\(\iota:A\to B\)</span> and every morphism <span class="SimpleMath">\(\tau:A \to I\)</span>, there exists a colift morphism of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\iota\)</span>. The exact category <span class="SimpleMath">\((\CC,\EE)\)</span> is said to have enough <span class="SimpleMath">\(\EE\)</span>-injectives if for each object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>, there exists an inflation <span class="SimpleMath">\(\iota_A:A \to I_A\)</span> where <span class="SimpleMath">\(I_A\)</span> is an <span class="SimpleMath">\(\EE\)</span>-injective object.</p>

<p><a id="X84A9AF9484068AC1" name="X84A9AF9484068AC1"></a></p>

<h5>1.2-33 IsExactCategoryWithEnoughExactInjectives</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsExactCategoryWithEnoughExactInjectives</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p>The input is a <strong class="pkg">CAP</strong> category. The output is <code class="code">true</code> if <span class="SimpleMath">\(\CC\)</span> is an exact category with respect to some class <span class="SimpleMath">\(\EE\)</span> of short exact sequences and <span class="SimpleMath">\((\CC,\EE)\)</span> has enough <span class="SimpleMath">\(\EE\)</span>-injectives.</p>

<p><a id="X7CAFD3007E885932" name="X7CAFD3007E885932"></a></p>

<h5>1.2-34 IsExactInjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsExactInjectiveObject</code>( <var class="Arg">I</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: a boolian</p>

<p>The argument is an object <span class="SimpleMath">\(I\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is whether or not <span class="SimpleMath">\(I\)</span> is an <span class="SimpleMath">\(\EE\)</span>-injective object.</p>

<p><a id="X7F8F3C02820441DC" name="X7F8F3C02820441DC"></a></p>

<h5>1.2-35 ExactInjectiveColift</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExactInjectiveColift</code>( <var class="Arg">iota</var>, <var class="Arg">tau</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: a morphism <span class="SimpleMath">\(\lambda:B \to I\)</span></p>

<p>The arguments are an inflation <span class="SimpleMath">\(\iota:A\to B\)</span> and a morphism <span class="SimpleMath">\(\tau:A\to I\)</span> where <span class="SimpleMath">\(I\)</span> is an <span class="SimpleMath">\(\EE\)</span>-injective object. The output is a colift morphism <span class="SimpleMath">\(\lambda:B \to I\)</span> of <span class="SimpleMath">\(\tau\)</span> along <span class="SimpleMath">\(\iota\)</span>, i.e., <span class="SimpleMath">\(\comp{\iota}{\lambda} \sim \tau\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota := KernelEmbedding( mu );</span>
&lt;A monomorphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConflationPair( iota, ExactCokernelProjection( iota ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := Source( iota );</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1} 
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := GradedRow( [ [ [0], 2 ], [ [-1], 2 ], [ [-2], 1 ] ], EEE );</span>
&lt;A graded row of rank 5&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := AsFreydCategoryObject( I );</span>
&lt;A projective object in Category of f.p. graded left modules over Q{e0,e1} 
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsExactInjectiveObject( I );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Hom_AI := BasisOfExternalHom( A, I );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( Hom_AI );</span>
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">tau := Random( Hom_AI );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lambda := ExactInjectiveColift( iota, tau );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( iota, lambda ), tau );</span>
true
</pre></div>

<p><a id="X869DA05B85F7F112" name="X869DA05B85F7F112"></a></p>

<h5>1.2-36 SomeExactInjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SomeExactInjectiveObject</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an <span class="SimpleMath">\(\EE\)</span>-injective object</p>

<p>The argument is an object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is an <span class="SimpleMath">\(\EE\)</span>-injective object <span class="SimpleMath">\(I_A\)</span> such that there exists an inflation <span class="SimpleMath">\(A \to I_A\)</span>.</p>

<p><a id="X7AD566E9805DA937" name="X7AD566E9805DA937"></a></p>

<h5>1.2-37 InflationIntoSomeExactInjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; InflationIntoSomeExactInjectiveObject</code>( <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>Returns: an inflation <span class="SimpleMath">\(A \to I_A\)</span></p>

<p>The argument is an object <span class="SimpleMath">\(A\)</span> in <span class="SimpleMath">\(\CC\)</span>. The output is an inflation <span class="SimpleMath">\(\iota_A:A \to I_A\)</span> where <span class="SimpleMath">\(I_A = \mathrm{SomeExactInjectiveObject}(A)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsExactCategoryWithEnoughExactInjectives( Grmod_E );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U;</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I_U := SomeExactInjectiveObject( U );</span>
&lt;An object in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsExactInjectiveObject( I_U );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota_U := InflationIntoSomeExactInjectiveObject( U );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsConflationPair( iota_U, ExactCokernelProjection( iota_U ) );</span>
true
</pre></div>

<p><a id="X85E3864B79AE0B00" name="X85E3864B79AE0B00"></a></p>

<h5>1.2-38 IsLiftableAlongDeflationFromSomeExactProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsLiftableAlongDeflationFromSomeExactProjectiveObject</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p>The argument if a morphism <span class="SimpleMath">\(\alpha:A\to B\)</span> in an exact category <span class="SimpleMath">\((\CC,\EE)\)</span> with enough <span class="SimpleMath">\(\EE\)</span>-projectives. The output is whether or not <span class="SimpleMath">\(\alpha\)</span> lifts along <span class="SimpleMath">\(p_B:P_B\to B\)</span> where <span class="SimpleMath">\(p_B=\mathrm{DeflationFromSomeExactProjectiveObject}(B)\)</span>.</p>

<p><a id="X78BDE2BA7950284D" name="X78BDE2BA7950284D"></a></p>

<h5>1.2-39 LiftAlongDeflationFromSomeExactProjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftAlongDeflationFromSomeExactProjectiveObject</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The argument is a morphism <span class="SimpleMath">\(\alpha:A\to B\)</span> such that <span class="SimpleMath">\(\alpha\)</span> lifts along <span class="SimpleMath">\(p_B:P_B \to B\)</span> where <span class="SimpleMath">\(p_B=\mathrm{DeflationFromSomeExactProjectiveObject}(B)\)</span>. The output is a lift morphism <span class="SimpleMath">\(\lambda: A \to P_B\)</span> of <span class="SimpleMath">\(\alpha\)</span> along <span class="SimpleMath">\(p_B\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">V = Range( mu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi_V := DeflationFromSomeExactProjectiveObject( V );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsLiftableAlongDeflationFromSomeExactProjectiveObject( mu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lambda := LiftAlongDeflationFromSomeExactProjectiveObject( mu );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lambda, pi_V ), mu );</span>
true
</pre></div>

<p><a id="X87D53EAB8275CCD8" name="X87D53EAB8275CCD8"></a></p>

<h5>1.2-40 IsColiftableAlongInflationIntoSomeExactInjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsColiftableAlongInflationIntoSomeExactInjectiveObject</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p>The argument if a morphism <span class="SimpleMath">\(\alpha:A\to B\)</span> in an exact category <span class="SimpleMath">\((\CC,\EE)\)</span> with enough <span class="SimpleMath">\(\EE\)</span>-injectives. The output is whether or not <span class="SimpleMath">\(\alpha\)</span> colifts along <span class="SimpleMath">\(\iota_A:A\to I_A\)</span> where <span class="SimpleMath">\(\iota_A=\mathrm{InflationIntoSomeExactInjectiveObject}(A)\)</span>.</p>

<p><a id="X7E1207BA7C66FAFE" name="X7E1207BA7C66FAFE"></a></p>

<h5>1.2-41 ColiftAlongInflationIntoSomeExactInjectiveObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ColiftAlongInflationIntoSomeExactInjectiveObject</code>( <var class="Arg">alpha</var> )</td><td class="tdright">(&nbsp;attribute&nbsp;)</td></tr></table></div>
<p>The argument is a morphism <span class="SimpleMath">\(\alpha:A\to B\)</span> such that <span class="SimpleMath">\(\alpha\)</span> colifts along <span class="SimpleMath">\(\iota_A:A \to I_A\)</span> where <span class="SimpleMath">\(\iota_A=\mathrm{InflationIntoSomeExactInjectiveObject}(A)\)</span>. The output is a colift morphism <span class="SimpleMath">\(\lambda: I_A \to B\)</span> of <span class="SimpleMath">\(\alpha\)</span> along <span class="SimpleMath">\(\iota_A\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U = Source( mu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota_U := InflationIntoSomeExactInjectiveObject( U );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsColiftableAlongInflationIntoSomeExactInjectiveObject( mu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lambda := ColiftAlongInflationIntoSomeExactInjectiveObject( mu );</span>
&lt;A morphism in Category of f.p. graded left modules over Q{e0,e1}
(with weights [ -1, -1 ])&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( iota_U, lambda ), mu );</span>
true
</pre></div>

<p><a id="X7E777F887E00910C" name="X7E777F887E00910C"></a></p>

<h5>1.2-42 IsFrobeniusCategory</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsFrobeniusCategory</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;property&nbsp;)</td></tr></table></div>
<p>Returns: <code class="code">true</code> or <code class="code">false</code></p>

<p>The argument is a <strong class="pkg">CAP</strong> category. The output is <code class="code">true</code> if</p>


<ul>
<li><p><span class="SimpleMath">\(\CC\)</span> is exact with respect to some class <span class="SimpleMath">\(\EE\)</span> of short exact sequences,</p>

</li>
<li><p><span class="SimpleMath">\((\CC,\EE)\)</span> has enough <span class="SimpleMath">\(\EE\)</span>-projectives and <span class="SimpleMath">\(\EE\)</span>-injectives,</p>

</li>
<li><p>an object in <span class="SimpleMath">\(\CC\)</span> is <span class="SimpleMath">\(\EE\)</span>-projective if and only if it is <span class="SimpleMath">\(\EE\)</span>-injective.</p>

</li>
</ul>

<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap0_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap2_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
