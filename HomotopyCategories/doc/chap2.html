<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (HomotopyCategories) - Chapter 2: Examples and Tests</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap2"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapInd.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap2_mj.html">[MathJax on]</a></p>
<p><a id="X7967FE8E7BBDF485" name="X7967FE8E7BBDF485"></a></p>
<div class="ChapSects"><a href="chap2.html#X7967FE8E7BBDF485">2 <span class="Heading">Examples and Tests</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X87A4F8897AE55F10">2.1 <span class="Heading">Homotopy Category of Freyd Categories</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X804B9FCF83F5EDBB">2.2 <span class="Heading">Homotopy Category of Left-Presentations Categories</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X87E84EBF78EC7100">2.3 <span class="Heading">Homotopy Category of Presheaves categories (Quiver Representations)</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap2.html#X81B108B17F275A81">2.4 <span class="Heading">Strong Exceptional Sequence in the Homotopy Category of the Additive Closure of an Algebroid</span></a>
</span>
</div>
</div>

<h3>2 <span class="Heading">Examples and Tests</span></h3>

<p><a id="X87A4F8897AE55F10" name="X87A4F8897AE55F10"></a></p>

<h4>2.1 <span class="Heading">Homotopy Category of Freyd Categories</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FreydCategoriesForCAP", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "HomotopyCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HOMALG_IO.show_banners := false;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationalsInSingular( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ_xy := QQ["x, y"];</span>
Q[x,y]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ_xy_rows := CategoryOfRows( QQ_xy );</span>
Rows( Q[x,y] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ_xy_mod := FreydCategory( QQ_xy_rows );</span>
Freyd( Rows( Q[x,y] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K_QQ_xy_mod := HomotopyCategoryByCochains( QQ_xy_mod );</span>
Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := HomalgMatrix("[[0,0,25*y+9,30,0,0,7*y], [0,0,0,0,24*x,0,20*y], [0,0,0,0,0,24,0], [0,0,29*x+27*y+10,0,0,0,0], [0,0,0,0,34,0,0], [0,0,0,0,0,0,0], [0,0,0,33*y,4*y+12,0,42], [0,20*x+34,0,0,0,0,0], [0,0,0,43*x,0,0,24*y], [0,0,0,0,0,0,0]]", 10, 7, QQ_xy );</span>
&lt;A 10 x 7 matrix over an external ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := HomalgMatrix("[[0,0,25*y+9], [0,0,725*x+7], [0,10*x+17,0]]", 3, 3, QQ_xy );</span>
&lt;A 3 x 3 matrix over an external ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := ObjectConstructor( QQ_xy_mod, m / QQ_xy_rows );</span>
&lt;An object in Freyd( Rows( Q[x,y] ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( M );</span>

--------------------------------
Relation morphism:
--------------------------------

Source: 
A row module over Q[x,y] of rank 10

Matrix: 
0,0,      25*y+9,      30,  0,     0, 7*y, 
0,0,      0,           0,   24*x,  0, 20*y,
0,0,      0,           0,   0,     24,0,   
0,0,      29*x+27*y+10,0,   0,     0, 0,   
0,0,      0,           0,   34,    0, 0,   
0,0,      0,           0,   0,     0, 0,   
0,0,      0,           33*y,4*y+12,0, 42,  
0,20*x+34,0,           0,   0,     0, 0,   
0,0,      0,           43*x,0,     0, 24*y,
0,0,      0,           0,   0,     0, 0    

Range: 
A row module over Q[x,y] of rank 7

A morphism in Rows( Q[x,y] )


--------------------------------
General description:
--------------------------------

An object in Freyd( Rows( Q[x,y] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( M );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsProjective( M );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := ObjectConstructor( QQ_xy_mod, n / QQ_xy_rows );</span>
&lt;An object in Freyd( Rows( Q[x,y] ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N );</span>

--------------------------------
Relation morphism:
--------------------------------

Source: 
A row module over Q[x,y] of rank 3

Matrix: 
0,0,      25*y+9, 
0,0,      725*x+7,
0,10*x+17,0       

Range: 
A row module over Q[x,y] of rank 3

A morphism in Rows( Q[x,y] )


--------------------------------
General description:
--------------------------------

An object in Freyd( Rows( Q[x,y] ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := HomalgMatrix( "[[1,0,0], [0,1,0], [0,0,1], [0,0,-5/6*y-3/10], [0,0,0], [0,0,0], [0,0,0]]", 7, 3, QQ_xy );</span>
&lt;A 7 x 3 matrix over an external ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := MorphismConstructor( QQ_xy_mod, M, a / QQ_xy_rows, N );</span>
&lt;A morphism in Freyd( Rows( Q[x,y] ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( alpha );</span>

--------------------------------
Source:
--------------------------------

Source: 
A row module over Q[x,y] of rank 10

Matrix: 
0,0,      25*y+9,      30,  0,     0, 7*y, 
0,0,      0,           0,   24*x,  0, 20*y,
0,0,      0,           0,   0,     24,0,   
0,0,      29*x+27*y+10,0,   0,     0, 0,   
0,0,      0,           0,   34,    0, 0,   
0,0,      0,           0,   0,     0, 0,   
0,0,      0,           33*y,4*y+12,0, 42,  
0,20*x+34,0,           0,   0,     0, 0,   
0,0,      0,           43*x,0,     0, 24*y,
0,0,      0,           0,   0,     0, 0    

Range: 
A row module over Q[x,y] of rank 7

A morphism in Rows( Q[x,y] )


--------------------------------
Morphism datum:
--------------------------------

Source: 
A row module over Q[x,y] of rank 7

Matrix: 
1,0,0,          
0,1,0,          
0,0,1,          
0,0,-5/6*y-3/10,
0,0,0,          
0,0,0,          
0,0,0           

Range: 
A row module over Q[x,y] of rank 3

A morphism in Rows( Q[x,y] )


--------------------------------
Range:
--------------------------------

Source: 
A row module over Q[x,y] of rank 3

Matrix: 
0,0,      25*y+9, 
0,0,      725*x+7,
0,10*x+17,0       

Range: 
A row module over Q[x,y] of rank 3

A morphism in Rows( Q[x,y] )


--------------------------------
General description:
--------------------------------

A morphism in Freyd( Rows( Q[x,y] ) )


<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := CreateComplex( K_QQ_xy_mod, [ MorphismIntoZeroObject( M ) ], 0 );</span>
&lt;An object in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ 0 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectsSupport( M );</span>
[ 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectAt( M, 0 ); # or M[0]</span>
&lt;An object in Freyd( Rows( Q[x,y] ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DifferentialAt( M, 0 ); # or M^0</span>
&lt;A zero, split epimorphism in Freyd( Rows( Q[x,y] ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := CreateComplex( K_QQ_xy_mod, [ MorphismIntoZeroObject( N ) ], 0 );</span>
&lt;An object in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ 0 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectsSupport( N );</span>
[ 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CreateComplexMorphism( K_QQ_xy_mod, M, [ alpha ], 0, N );</span>
&lt;A morphism in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ 0 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p_M := ProjectiveResolution( M, true );</span>
&lt;An object in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ -2 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q_M := QuasiIsomorphismFromProjectiveResolution( M, true );</span>
&lt;A morphism in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ -2 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p_N := ProjectiveResolution( N, true );</span>
&lt;An object in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ -2 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q_N := QuasiIsomorphismFromProjectiveResolution( N, true );</span>
&lt;A morphism in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ -2 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p_alpha := MorphismBetweenProjectiveResolutions( alpha, true );</span>
&lt;A morphism in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ -2 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( p_alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MorphismAt( p_alpha, 0 );</span>
&lt;A morphism in Freyd( Rows( Q[x,y] ) )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( p_alpha, q_N ) = PreCompose(q_M, alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := LocalizationFunctorByProjectiveObjects( K_QQ_xy_mod );</span>
Localization functor via projective objects
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( L );</span>
Localization functor via projective objects:

Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) )
  |
  V
Homotopy category by cochains( FullSubcategoryOfProjectiveObjects( Freyd( Rows( Q[x,y] ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L_M := ApplyFunctor( L, M );</span>
&lt;An object in Homotopy category by cochains( FullSubcategoryOfProjectiveObjects( Freyd( Rows( Q[x,y] ) ) ) ) supported on the interval [ -2 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( ApplyFunctor( L, alpha ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cone_q_M := StandardConeObject( q_M );</span>
&lt;An object in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ -3 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CohomologySupport( cone_q_M ); # quasi-iso &lt;-&gt; cone is acyclic</span>
[ ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota_q_M := MorphismIntoStandardConeObject( q_M );</span>
&lt;A morphism in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ -3 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( iota_q_M );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi_q_M := MorphismFromStandardConeObject( q_M );</span>
&lt;A morphism in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ -3 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( PreCompose( iota_q_M, pi_q_M ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu := MorphismBetweenStandardConeObjects(q_M, p_alpha, alpha, q_N);</span>
&lt;A morphism in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ -3 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( nu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( nu );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( nu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ShiftOfObjectByInteger( p_M, 2 );</span>
&lt;An object in Homotopy category by cochains( Freyd( Rows( Q[x,y] ) ) ) supported on the interval [ -4 .. -1 ]&gt;
</pre></div>

<p><a id="X804B9FCF83F5EDBB" name="X804B9FCF83F5EDBB"></a></p>

<h4>2.2 <span class="Heading">Homotopy Category of Left-Presentations Categories</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "ModulePresentations", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "HomotopyCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">HOMALG_IO.show_banners := false;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationalsInSingular( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ_xy := QQ["x, y"];</span>
Q[x,y]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ_xy_mod := LeftPresentations( QQ_xy );</span>
Category of left presentations of Q[x,y]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K_QQ_xy_mod := HomotopyCategoryByCochains( QQ_xy_mod );</span>
Homotopy category by cochains( Category of left presentations of Q[x,y] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := HomalgMatrix("[[0,0,25*y+9,30,0,0,7*y], [0,0,0,0,24*x,0,20*y], [0,0,0,0,0,24,0], [0,0,29*x+27*y+10,0,0,0,0], [0,0,0,0,34,0,0], [0,0,0,0,0,0,0], [0,0,0,33*y,4*y+12,0,42], [0,20*x+34,0,0,0,0,0], [0,0,0,43*x,0,0,24*y], [0,0,0,0,0,0,0]]", 10, 7, QQ_xy );</span>
&lt;A 10 x 7 matrix over an external ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := HomalgMatrix("[[0,0,25*y+9], [0,0,725*x+7], [0,10*x+17,0]]", 3, 3, QQ_xy );</span>
&lt;A 3 x 3 matrix over an external ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := AsLeftPresentation( QQ_xy_mod, m );</span>
&lt;An object in Category of left presentations of Q[x,y]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( M );</span>
0,0,      25*y+9,      30,  0,     0, 7*y, 
0,0,      0,           0,   24*x,  0, 20*y,
0,0,      0,           0,   0,     24,0,   
0,0,      29*x+27*y+10,0,   0,     0, 0,   
0,0,      0,           0,   34,    0, 0,   
0,0,      0,           0,   0,     0, 0,   
0,0,      0,           33*y,4*y+12,0, 42,  
0,20*x+34,0,           0,   0,     0, 0,   
0,0,      0,           43*x,0,     0, 24*y,
0,0,      0,           0,   0,     0, 0    

An object in Category of left presentations of Q[x,y]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForObjects( M );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsProjective( M );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := AsLeftPresentation( QQ_xy_mod, n );</span>
&lt;An object in Category of left presentations of Q[x,y]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( N );</span>
0,0,      25*y+9, 
0,0,      725*x+7,
0,10*x+17,0       

An object in Category of left presentations of Q[x,y]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := HomalgMatrix( "[[1,0,0], [0,1,0], [0,0,1], [0,0,-5/6*y-3/10], [0,0,0], [0,0,0], [0,0,0]]", 7, 3, QQ_xy );</span>
&lt;A 7 x 3 matrix over an external ring&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := PresentationMorphism( M, a, N );</span>
&lt;A morphism in Category of left presentations of Q[x,y]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( alpha );</span>
1,0,0,
0,1,0,
0,0,1,
0,0,-5/6*y-3/10,
0,0,0,
0,0,0,
0,0,0

A morphism in Category of left presentations of Q[x,y]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := CreateComplex( K_QQ_xy_mod, [ MorphismIntoZeroObject( M ) ], 0 );</span>
&lt;An object in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ 0 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectsSupport( M );</span>
[ 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectAt( M, 0 );</span>
&lt;An object in Category of left presentations of Q[x,y]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DifferentialAt( M, 0 );</span>
&lt;A zero, split epimorphism in Category of left presentations of Q[x,y]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := CreateComplex( K_QQ_xy_mod, [ MorphismIntoZeroObject( N ) ], 0 );</span>
&lt;An object in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ 0 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectsSupport( N );</span>
[ 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := CreateComplexMorphism( K_QQ_xy_mod, M, [ alpha ], 0, N );</span>
&lt;A morphism in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ 0 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p_M := ProjectiveResolution( M, true );</span>
&lt;An object in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ -3 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q_M := QuasiIsomorphismFromProjectiveResolution( M, true );</span>
&lt;A morphism in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ -3 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p_N := ProjectiveResolution( N, true );</span>
&lt;An object in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ -2 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q_N := QuasiIsomorphismFromProjectiveResolution( N, true );</span>
&lt;A morphism in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ -2 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p_alpha := MorphismBetweenProjectiveResolutions( alpha, true );</span>
&lt;A morphism in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ -3 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( p_alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MorphismAt( p_alpha, 0 );</span>
&lt;A morphism in Category of left presentations of Q[x,y]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( p_alpha, q_N ) = PreCompose(q_M, alpha );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cone_q_M := StandardConeObject( q_M );</span>
&lt;An object in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ -4 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CohomologySupport( cone_q_M ); # quasi-iso &lt;-&gt; cone is acyclic</span>
[ ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota_q_M := MorphismIntoStandardConeObject( q_M );</span>
&lt;A morphism in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ -4 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( iota_q_M );</span>

== 1 =======================
(an empty 0 x 0 matrix)

A zero, isomorphism in Category of left presentations of Q[x,y]

== 0 =======================
1,0,0,0,0,0,0,
0,1,0,0,0,0,0,
0,0,1,0,0,0,0,
0,0,0,1,0,0,0,
0,0,0,0,1,0,0,
0,0,0,0,0,1,0,
0,0,0,0,0,0,1 

A morphism in Category of left presentations of Q[x,y]

== -1 =======================
(an empty 0 x 7 matrix)

A zero, split monomorphism in Category of left presentations of Q[x,y]

== -2 =======================
(an empty 0 x 8 matrix)

A zero, split monomorphism in Category of left presentations of Q[x,y]

== -3 =======================
(an empty 0 x 3 matrix)

A zero, split monomorphism in Category of left presentations of Q[x,y]

== -4 =======================
(an empty 0 x 1 matrix)

A zero, split monomorphism in Category of left presentations of Q[x,y]


A morphism in Homotopy category by cochains( Category of left presentations of Q[x,y] ) defined by the above data

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( iota_q_M );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pi_q_M := MorphismFromStandardConeObject( q_M );</span>
&lt;A morphism in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ -4 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( pi_q_M );</span>
== 1 =======================
(an empty 0 x 0 matrix)

A zero, isomorphism in Category of left presentations of Q[x,y]

== 0 =======================
(an empty 7 x 0 matrix)

A morphism in Category of left presentations of Q[x,y]

== -1 =======================
1,0,0,0,0,0,0,
0,1,0,0,0,0,0,
0,0,1,0,0,0,0,
0,0,0,1,0,0,0,
0,0,0,0,1,0,0,
0,0,0,0,0,1,0,
0,0,0,0,0,0,1 

A morphism in Category of left presentations of Q[x,y]

== -2 =======================
1,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,
0,0,0,1,0,0,0,0,
0,0,0,0,1,0,0,0,
0,0,0,0,0,1,0,0,
0,0,0,0,0,0,1,0,
0,0,0,0,0,0,0,1 

A morphism in Category of left presentations of Q[x,y]

== -3 =======================
1,0,0,
0,1,0,
0,0,1 

A morphism in Category of left presentations of Q[x,y]

== -4 =======================
1

A morphism in Category of left presentations of Q[x,y]


A morphism in Homotopy category by cochains( Category of left presentations of Q[x,y] ) defined by the above data
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">nu := MorphismBetweenStandardConeObjects(q_M, p_alpha, alpha, q_N);</span>
&lt;A morphism in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ -4 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( nu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( nu );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( nu );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ShiftOfObjectByInteger( p_M, 2 );</span>
&lt;An object in Homotopy category by cochains( Category of left presentations of Q[x,y] ) supported on the interval [ -5 .. -1 ]&gt;
</pre></div>

<p><a id="X87E84EBF78EC7100" name="X87E84EBF78EC7100"></a></p>

<h4>2.3 <span class="Heading">Homotopy Category of Presheaves categories (Quiver Representations)</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FunctorCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "HomotopyCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q_O := FinQuiver( "q_O(A,B,C)[x:A-&gt;B,y:A-&gt;B,z:B-&gt;C,w:B-&gt;C]" );</span>
FinQuiver( "q_O(A,B,C)[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P_O := PathCategory( q_O );</span>
PathCategory( FinQuiver( "q_O(A,B,C)[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rho_O := [ [ P_O.xz, P_O.yw ] ];</span>
[ [ x⋅z:(A) -≻ (C), y⋅w:(A) -≻ (C) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">quotient_P_O := QuotientCategory( P_O, rho_O );</span>
PathCategory( FinQuiver( "q_O(A,B,C)[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C]" ) ) / [ x⋅z = y⋅w ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := QQ;</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k_quotient_P_O := k[quotient_P_O];</span>
Q-LinearClosure( PathCategory( FinQuiver( "q_O(A,B,C)[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C]" ) ) / [ x⋅z = y⋅w ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_O := AlgebroidFromDataTables( k_quotient_P_O );</span>
Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension( A_O );</span>
10
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAdmissibleAlgebroid( A_O );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := 2 * A_O.x + 3 * A_O.y;</span>
&lt;2*x + 3*y:(A) -≻ (B)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( A_O );</span>
PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( PSh );</span>
A CAP category with name PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ):

59 primitive operations were used to derive 345 operations for this category which algorithmically
* IsCategoryWithDecidableColifts
* IsCategoryWithDecidableLifts
* IsEquippedWithHomomorphismStructure
* IsLinearCategoryOverCommutativeRingWithFinitelyGeneratedFreeExternalHoms
* IsAbelianCategoryWithEnoughInjectives
* IsAbelianCategoryWithEnoughProjectives
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">indec_projs := IndecomposableProjectiveObjects( PSh );</span>
[ &lt;(A)-&gt;1, (B)-&gt;0, (C)-&gt;0; (x)-&gt;0x1, (y)-&gt;0x1, (z)-&gt;0x0, (w)-&gt;0x0&gt;, &lt;(A)-&gt;2, (B)-&gt;1, (C)-&gt;0; (x)-&gt;1x2, (y)-&gt;1x2, (z)-&gt;0x1, (w)-&gt;0x1&gt;, 
  &lt;(A)-&gt;3, (B)-&gt;2, (C)-&gt;1; (x)-&gt;2x3, (y)-&gt;2x3, (z)-&gt;1x2, (w)-&gt;1x2&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">indec_injs := IndecomposableInjectiveObjects( PSh );</span>
[ &lt;(A)-&gt;1, (B)-&gt;2, (C)-&gt;3; (x)-&gt;2x1, (y)-&gt;2x1, (z)-&gt;3x2, (w)-&gt;3x2&gt;, &lt;(A)-&gt;0, (B)-&gt;1, (C)-&gt;2; (x)-&gt;1x0, (y)-&gt;1x0, (z)-&gt;2x1, (w)-&gt;2x1&gt;, 
  &lt;(A)-&gt;0, (B)-&gt;0, (C)-&gt;1; (x)-&gt;0x0, (y)-&gt;0x0, (z)-&gt;1x0, (w)-&gt;1x0&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C_PSh := ComplexesCategoryByCochains( PSh );</span>
Complexes category by cochains( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">K_PSh := HomotopyCategoryByCochains( PSh );</span>
Homotopy category by cochains( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( K_PSh );</span>
A CAP category with name Homotopy category by cochains( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) ):

50 primitive operations were used to derive 209 operations for this category which algorithmically
* IsEquippedWithHomomorphismStructure
* IsLinearCategoryOverCommutativeRingWithFinitelyGeneratedFreeExternalHoms
* IsAdditiveCategory
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L_proj := LocalizationFunctorByProjectiveObjects( K_PSh );</span>
Localization functor via projective objects
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( L_proj );</span>
Localization functor via projective objects:

Homotopy category by cochains( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) )
  |
  V
Homotopy category by cochains( FullSubcategoryOfProjectiveObjects( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := BasisOfExternalHom( indec_projs[1], indec_projs[2] )[1];</span>
&lt;(A)-&gt;1x2, (B)-&gt;0x1, (C)-&gt;0x0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEpimorphism( f );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := CokernelObject( f );</span>
&lt;(A)-&gt;1, (B)-&gt;1, (C)-&gt;0; (x)-&gt;1x1, (y)-&gt;1x1, (z)-&gt;0x1, (w)-&gt;0x1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := CreateComplex( K_PSh, [ UniversalMorphismIntoZeroObject( R ) ], 0 );</span>
&lt;An object in Homotopy category by cochains( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) ) supported on the interval [ 0 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iota_R := QuasiIsomorphismIntoInjectiveResolution( R, true );</span>
&lt;A morphism in Homotopy category by cochains( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) ) supported on the interval [ 0 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( iota_R );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsQuasiIsomorphism( iota_R );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CohomologySupport( Source( iota_R ) );</span>
[ 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CohomologySupport( Target( iota_R ) );</span>
[ 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L_proj_iota_R := ApplyFunctor( L_proj, iota_R );</span>
&lt;A morphism in Homotopy category by cochains( FullSubcategoryOfProjectiveObjects( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) ) ) supported on the interval [ -1 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsIsomorphism( L_proj_iota_R );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">inv_L_proj_iota_R := InverseForMorphisms( L_proj_iota_R );</span>
&lt;A morphism in Homotopy category by cochains( FullSubcategoryOfProjectiveObjects( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) ) ) supported on the interval [ -1 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">u := PreCompose( L_proj_iota_R, inv_L_proj_iota_R );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( Source( L_proj_iota_R ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZeroForMorphisms( u - id );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w := WitnessForBeingHomotopicToZeroMorphism( u - id ); # the homotopy maps</span>
&lt;ZFunction&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">w[0];</span>
A morphism in full subcategory given by: &lt;(A)-&gt;2x1, (B)-&gt;1x0, (C)-&gt;0x0&gt;
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "FunctorCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "HomotopyCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q_O := FinQuiver( "q_O(A,B,C)[x:A-&gt;B,y:A-&gt;B,z:B-&gt;C,w:B-&gt;C]" );</span>
FinQuiver( "q_O(A,B,C)[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P_O := PathCategory( q_O );</span>
PathCategory( FinQuiver( "q_O(A,B,C)[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rho_O := [ [ P_O.xz, P_O.yw ] ];</span>
[ [ x⋅z:(A) -≻ (C), y⋅w:(A) -≻ (C) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">quotient_P_O := QuotientCategory( P_O, rho_O );</span>
PathCategory( FinQuiver( "q_O(A,B,C)[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C]" ) ) / [ x⋅z = y⋅w ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := QQ;</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k_quotient_P_O := k[quotient_P_O];</span>
Q-LinearClosure( PathCategory( FinQuiver( "q_O(A,B,C)[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C]" ) ) / [ x⋅z = y⋅w ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_O := AlgebroidFromDataTables( k_quotient_P_O );</span>
Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Dimension( A_O );</span>
10
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsAdmissibleAlgebroid( A_O );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PSh := PreSheaves( A_O );</span>
PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y1 := YonedaEmbeddingOfSourceCategory( PSh );</span>
Yoneda embedding functor
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Y1 );</span>
Yoneda embedding functor:

Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms
  |
  V
PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( Y1, A_O.x );</span>
&lt;(A)-&gt;1x2, (B)-&gt;0x1, (C)-&gt;0x0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y2 := ExtendFunctorToAdditiveClosureOfSource( Y1 );</span>
Extension of Yoneda embedding functor to a functor from the additive closure of the source
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Y2 );</span>
Extension of Yoneda embedding functor to a functor from the additive closure of the source:

AdditiveClosure( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms )
  |
  V
PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">add_A_O := SourceOfFunctor( Y2 );</span>
AdditiveClosure( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( Y2, add_A_O.x );</span>
&lt;(A)-&gt;1x2, (B)-&gt;0x1, (C)-&gt;0x0&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y3 := ExtendFunctorToFreydCategory( Y2 ); # Y3 is an equivalence of categories</span>
Extension to FreydCategory( Source( Extension of Yoneda embedding functor to a functor from the additive closure of the source ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Y3 );</span>
Extension to FreydCategory( Source( Extension of Yoneda embedding functor to a functor from the additive closure of the source ) ):

Freyd( AdditiveClosure( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms ) )
  |
  V
PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( SourceOfFunctor( Y3 ) );</span>
A CAP category with name Freyd( AdditiveClosure( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms ) ):

48 primitive operations were used to derive 342 operations for this category which algorithmically
* IsCategoryWithDecidableColifts
* IsCategoryWithDecidableLifts
* IsEquippedWithHomomorphismStructure
* IsLinearCategoryOverCommutativeRingWithFinitelyGeneratedFreeExternalHoms
* IsAbelianCategoryWithEnoughProjectives
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( RangeOfFunctor( Y3 ) );</span>
A CAP category with name PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ):

59 primitive operations were used to derive 345 operations for this category which algorithmically
* IsCategoryWithDecidableColifts
* IsCategoryWithDecidableLifts
* IsEquippedWithHomomorphismStructure
* IsLinearCategoryOverCommutativeRingWithFinitelyGeneratedFreeExternalHoms
* IsAbelianCategoryWithEnoughInjectives
* IsAbelianCategoryWithEnoughProjectives
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y4 := ExtendFunctorToHomotopyCategoriesByCochains( Y3 );</span>
Extension of ( Extension to FreydCategory( Source( Extension of Yoneda embedding functor to a functor from the additive closure of the source ) ) ) to homotopy categories by cochains
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( Y4 );</span>
Extension of ( Extension to FreydCategory( Source( Extension of Yoneda embedding functor to a functor from the additive closure of the source ) ) ) to homotopy categories by cochains:

Homotopy category by cochains( Freyd( AdditiveClosure( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms ) ) )
  |
  V
Homotopy category by cochains( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">repeat f := RandomMorphism( SourceOfFunctor( Y4 ), 3 );; until not IsZeroForMorphisms( f );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Y4_f := ApplyFunctor( Y4, f );</span>
&lt;A morphism in Homotopy category by cochains( PreSheaves( Q-algebroid( {A,B,C}[x:A-≻B,y:A-≻B,z:B-≻C,w:B-≻C] ) defined by 3 objects and 4 generating morphisms, Rows( Q ) ) ) supported on the interval [ -1 .. 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r1 := RankOfObject( HomomorphismStructureOnObjects( Source( f ), Target( f ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r2 := RankOfObject( HomomorphismStructureOnObjects( Source( Y4_f ), Target( Y4_f ) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r1 = r2;</span>
true
</pre></div>

<p><a id="X81B108B17F275A81" name="X81B108B17F275A81"></a></p>

<h4>2.4 <span class="Heading">Strong Exceptional Sequence in the Homotopy Category of the Additive Closure of an Algebroid</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "Algebroids", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "HomotopyCategories", false );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q_O := FinQuiver( "q_O(O0,O1,O2)[x0:O0-&gt;O1,x1:O0-&gt;O1,x2:O0-&gt;O1,y0:O1-&gt;O2,y1:O1-&gt;O2,y2:O1-&gt;O2]" );</span>
FinQuiver( "q_O(O0,O1,O2)[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetLaTeXStringsOfObjects( q_O, [ "\\mathcal{O}_{0}", "\\mathcal{O}_{1}", "\\mathcal{O}_{2}" ] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetLaTeXStringsOfMorphisms( q_O, [ "x_0", "x_1", "x_2", "y_0", "y_1", "y_2" ] );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P_O := PathCategory( q_O );</span>
PathCategory( FinQuiver( "q_O(O0,O1,O2)[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2, y2:O1-≻O2]" ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rho_O := [ [ P_O.x0y1, P_O.x1y0 ], [ P_O.x0y2, P_O.x2y0 ], [ P_O.x1y2, P_O.x2y1 ] ];</span>
[ [ x0⋅y1:(O0) -≻ (O2), x1⋅y0:(O0) -≻ (O2) ], [ x0⋅y2:(O0) -≻ (O2), x2⋅y0:(O0) -≻ (O2) ], [ x1⋅y2:(O0) -≻ (O2), x2⋅y1:(O0) -≻ (O2) ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">quotient_P_O := P_O / rho_O;</span>
PathCategory( FinQuiver( "q_O(O0,O1,O2)[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2]" ) ) / [ x0⋅y1 = x1⋅y0, x0⋅y2 = x2⋅y0, x1⋅y2 = x2⋅y1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">QQ := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k := QQ;</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">k_quotient_P_O := k[quotient_P_O];</span>
Q-LinearClosure( PathCategory( FinQuiver( "q_O(O0,O1,O2)[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2]" ) ) / [ x0⋅y1 = x1⋅y0, x0⋅y2 = x2⋅y0, x1⋅y2 = x2⋅y1 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_O := AlgebroidFromDataTables( k_quotient_P_O );</span>
Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">phi := 2 * A_O.x0 + 3 * A_O.x1 - A_O.x2;</span>
&lt;2*x0 + 3*x1 - 1*x2:(O0) -≻ (O1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_Oadd := AdditiveClosure( A_O );</span>
AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2, y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KA_Oadd := HomotopyCategoryByCochains( A_Oadd );</span>
Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">E10 := [ A_O.O0, A_O.O0, A_O.O0 ] / A_Oadd;</span>
&lt;An object in AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2, y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) defined by 3 underlying objects&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">E11 := [ A_O.O1, A_O.O1, A_O.O1 ] / A_Oadd;</span>
&lt;An object in AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2, y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) defined by 3 underlying objects&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">E12 := [ A_O.O2 ] / A_Oadd;</span>
&lt;An object in AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2, y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) defined by 1 underlying objects&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta_0 := AdditiveClosureMorphism(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        E10,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ [ A_O.x1, -A_O.x0, ZeroMorphism(A_O.O0, A_O.O1) ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          [ A_O.x2, ZeroMorphism(A_O.O0, A_O.O1), -A_O.x0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          [ ZeroMorphism(A_O.O0, A_O.O1), A_O.x2, -A_O.x1 ] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        E11 );</span>
&lt;A morphism in AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2, y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) defined by a 3 x 3 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta_1 := AdditiveClosureMorphism(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        E11,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ [ A_O.y0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          [ A_O.y1 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">          [ A_O.y2 ] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        E12 );</span>
&lt;A morphism in AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) defined by a 3 x 1 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">E1 := CreateComplex( KA_Oadd, [ delta_0, delta_1 ], 0 );</span>
&lt;An object in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ 0 .. 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">E20 := [ A_O.O0, A_O.O0, A_O.O0 ] / A_Oadd;</span>
&lt;An object in AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) defined by 3 underlying objects&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">E21 := [ A_O.O1] / A_Oadd;</span>
&lt;An object in AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) defined by 1 underlying objects&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">delta_0 := AdditiveClosureMorphism(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      E20,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      [ [ A_O.x0 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ A_O.x1 ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        [ A_O.x2 ] ],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      E21 );</span>
&lt;A morphism in AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) defined by a 3 x 1 matrix of underlying morphisms&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">E2 := CreateComplex( KA_Oadd, [ delta_0 ], 0 );</span>
&lt;An object in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ 0 .. 1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">E3 := CreateComplex( KA_Oadd, A_O.O0 / A_Oadd, 0 );</span>
&lt;An object in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">seq := CreateStrongExceptionalSequence( [ E1, E2, E3 ] );</span>
A strong exceptional sequence in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[ x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T := DirectSum( [ E1, E2, E3 ] );</span>
&lt;An object in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ 0 .. 2 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RankOfObject( HomStructure( E1, E1 ) ) = 1 and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  RankOfObject( HomStructure( E2, E2 ) ) = 1 and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    RankOfObject( HomStructure( E3, E3 ) ) = 1;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( HomStructure( E3, E2 ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  IsZero( HomStructure( E2, E1 ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    IsZero( HomStructure( E3, E1 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsZero( HomStructure( T, Shift( T, -2 ) ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  IsZero( HomStructure( T, Shift( T, -1 ) ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    IsZero( HomStructure( T, Shift( T, 1 ) ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">      IsZero( HomStructure( T, Shift( T, 2 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RankOfObject( HomStructure( T, T ) );</span>
12
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_E := AbstractionAlgebroid( seq );</span>
Q-algebroid( {E1,E2,E3}[m1_2_1:E1-≻E2,m1_2_2:E1-≻E2,m1_2_3:E1-≻E2,m2_3_1:E2-≻E3,m2_3_2:E2-≻E3,m2_3_3:E2-≻E3] ) defined by 3 objects and 6 generating morphisms
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q_E := UnderlyingQuiver( A_E );</span>
FinQuiver( "q(E1,E2,E3)[m1_2_1:E1-≻E2,m1_2_2:E1-≻E2,m1_2_3:E1-≻E2,m2_3_1:E2-≻E3,m2_3_2:E2-≻E3,m2_3_3:E2-≻E3]" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Assert( 0, Dimension( A_E ) = 12 );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := IsomorphismIntoAbstractionAlgebroid( seq );</span>
Isomorphism: strong exceptional sequence ⟶ abstraction algebroid
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := IsomorphismFromAbstractionAlgebroid( seq );</span>
Isomorphism: abstraction algebroid ⟶ strong exceptional sequence
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := A_E.("m1_2_1");</span>
&lt;1*m1_2_1:(E1) -≻ (E2)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Assert( 0, m = ApplyFunctor( a, ApplyFunctor( r, m ) ) );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">T_E := TriangulatedSubcategory( seq );</span>
TriangulatedSubcategory( A strong exceptional sequence in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O0 := CreateComplex( KA_Oadd, A_O.("O0") / A_Oadd, 0 );</span>
&lt;An object in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O1 := CreateComplex( KA_Oadd, A_O.("O1") / A_Oadd, 0 );</span>
&lt;An object in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O2 := CreateComplex( KA_Oadd, A_O.("O2") / A_Oadd, 0 );</span>
&lt;An object in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( AsSubcategoryCell( T_E, O0 ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    IsWellDefined( AsSubcategoryCell( T_E, O1 ) ) and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IsWellDefined( AsSubcategoryCell( T_E, O2 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := ReplacementFunctorIntoHomotopyCategoryOfAdditiveClosureOfAbstractionAlgebroid( seq );</span>
Replacement functor
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := ConvolutionFunctorFromHomotopyCategoryOfAdditiveClosureOfAbstractionAlgebroid( seq );</span>
Convolution functor
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G_O0 := ApplyFunctor( G, O0 );</span>
&lt;An object in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {E1,E2,E3}[m1_2_1:E1-≻E2,m1_2_2:E1-≻E2,m1_2_3:E1-≻E2,m2_3_1:E2-≻E3,m2_3_2:E2-≻E3,m2_3_3:E2-≻E3] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G_O1 := ApplyFunctor( G, O1 );</span>
&lt;An object in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {E1,E2,E3}[m1_2_1:E1-≻E2,m1_2_2:E1-≻E2,m1_2_3:E1-≻E2,m2_3_1:E2-≻E3,m2_3_2:E2-≻E3,m2_3_3:E2-≻E3] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ -1 .. 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G_O2 := ApplyFunctor( G, O2 );</span>
&lt;An object in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {E1,E2,E3}[m1_2_1:E1-≻E2,m1_2_2:E1-≻E2,m1_2_3:E1-≻E2,m2_3_1:E2-≻E3,m2_3_2:E2-≻E3,m2_3_3:E2-≻E3] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ -2 .. 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">epsilon := CounitOfConvolutionReplacementAdjunction( seq );</span>
Counit ϵ : F∘G ⟹ Id of the adjunction F ⊣ G
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">epsilon_O0 := ApplyNaturalTransformation( epsilon, O0 );</span>
&lt;A morphism in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">epsilon_O1 := ApplyNaturalTransformation( epsilon, O1 );</span>
&lt;A morphism in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ -1 .. 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">epsilon_O2 := ApplyNaturalTransformation( epsilon, O2 );</span>
&lt;A morphism in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ -2 .. 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( [ epsilon_O0, epsilon_O1, epsilon_O2 ], IsIsomorphism );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">i := InverseForMorphisms( DirectSumFunctorial( [ epsilon_O0, epsilon_O1, epsilon_O2 ] ) );</span>
&lt;A morphism in Homotopy category by cochains( AdditiveClosure( Q-algebroid( {O0,O1,O2}[x0:O0-≻O1,x1:O0-≻O1,x2:O0-≻O1,y0:O1-≻O2,y1:O1-≻O2,y2:O1-≻O2] ) defined by 3 objects and 6 generating morphisms ) ) supported on the interval [ -2 .. 0 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsWellDefined( i ) and IsIsomorphism( i );</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap1.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapInd.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="https://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
